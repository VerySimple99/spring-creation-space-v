<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css">
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.slim.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js"></script>
<title>Ajax Study5 - JSON with Fetch API</title>
</head>
<body>
<div class="container pt-4">
<!-- 모던 JavaScript fetch API를 이용한 JSON 데이터 처리 예제 -->
<h4>Modern JavaScript Ajax - JSON Data Processing</h4>

<button id="listBtn">상품리스트 가져오기</button>
<br><br>

<table class="table table-bordered">
    <thead>
        <tr>        
            <th>NO</th>
            <th>NAME</th>
            <th>MAKER</th>
            <th>PRICE</th>
        </tr>
    </thead>
    <tbody id="productList">
        <!-- 동적으로 생성될 상품 목록이 여기에 추가됩니다 -->
    </tbody>
</table>

<script>
// DOM이 완전히 로드된 후 이벤트 리스너 등록
document.addEventListener('DOMContentLoaded', function() {
    
    // 상품 리스트 버튼에 클릭 이벤트 리스너 등록
    document.getElementById('listBtn').addEventListener('click', async function() {
        try {
            // 서버에서 JSON 형태의 상품 리스트를 가져옴
            const response = await fetch('findAllProductList', {
                method: 'GET',
                headers: {
                    // JSON 데이터를 받을 것임을 명시 (선택사항이지만 명시적으로 표현)
                    'Accept': 'application/json'
                }
            });
            
            // 응답 상태 코드 확인 (200-299가 아니면 에러)
            if (!response.ok) {
                throw new Error(`서버 응답 에러: ${response.status} ${response.statusText}`);
            }
            
            // JSON 응답을 JavaScript 객체/배열로 파싱
            // Spring Boot의 @ResponseBody가 List<Product>를 JSON Array로 변환한 것을 받음
            const productArray = await response.json();
            
            // 기존 테이블 내용을 초기화
            const productListElement = document.getElementById('productList');
            productListElement.innerHTML = '';
            
            // 배열의 각 상품 정보를 테이블 행으로 변환
            let tableRowsHTML = '';
            
            // for...of 루프를 사용하여 각 상품 데이터를 순회
            for (const product of productArray) {
                tableRowsHTML += `
                    <tr>
                        <td>${product.productNo}</td>
                        <td>${product.name}</td>
                        <td>${product.maker}</td>
                        <td>${product.price.toLocaleString()}원</td>
                    </tr>
                `;
            }
            
            // 생성된 HTML을 테이블 body에 삽입
            productListElement.innerHTML = tableRowsHTML;
            
            // 성공 메시지를 콘솔에 출력 (개발 시 디버깅용)
            console.log(`총 ${productArray.length}개의 상품을 성공적으로 로드했습니다.`);
            
        } catch (error) {
            // 에러 발생 시 상세한 정보를 콘솔에 로그
            console.error('상품 리스트 로딩 실패:', error);
            
            // 사용자에게 친화적인 에러 메시지 표시
            const productListElement = document.getElementById('productList');
            productListElement.innerHTML = `
                <tr>
                    <td colspan="4" class="text-center text-danger">
                        상품 정보를 불러오는데 실패했습니다. 
                        <br>잠시 후 다시 시도해주세요.
                    </td>
                </tr>
            `;
        }
    });
});

/*
=== 핵심 개념 설명 ===

1. fetch API의 JSON 처리:
   - response.json()은 JSON 텍스트를 JavaScript 객체로 파싱
   - Spring Boot의 @ResponseBody + Jackson이 List<Product>를 JSON Array로 자동 변환
   - JavaScript에서는 이를 배열로 받아서 처리

2. 모던 JavaScript 패턴:
   - async/await: Promise 기반 비동기 처리의 동기적 표현
   - for...of: 배열 순회를 위한 직관적인 문법
   - 템플릿 리터럴(`${}`): 문자열 보간을 통한 HTML 생성
   - const/let: 블록 스코프 변수 선언

3. 에러 처리 베스트 프랙티스:
   - try-catch로 예외 상황 처리
   - response.ok로 HTTP 상태 확인
   - 사용자 친화적인 에러 메시지 표시
   - 개발자를 위한 console.error 로그

4. 실무에서의 고려사항:
   - 로딩 상태 표시 (스피너 등)
   - 데이터 검증 및 sanitization
   - 페이지네이션 처리
   - 캐싱 전략

5. jQuery vs Modern JavaScript 비교:
   - jQuery: 간결하지만 외부 의존성
   - Modern JS: 표준 API 사용, 더 명시적, 성능 우수
   - 최신 브라우저 지원 범위에서는 Modern JS 권장

이 예제는 실제 REST API와의 통신 패턴을 보여주며,
React나 Vue.js 같은 모던 프레임워크로 전환 시에도 
동일한 개념과 패턴을 사용할 수 있습니다.
*/
</script>
</div>
</body>
</html>
HTTP : HyperText Transfer Protocol 
HTTPS : HTTP Secure -> 보안 http protocol , 암호화된 버전 

Web Server : HTTP 에 의거해 HTML(html,css,javascript) 문서document 를 서비스 하는 서버 
				웹 브라우저 클라이언트에 정적인 컨텐트를 서비스하는 서버
				 
Web Application Server ( WAS ) : Web Server + Web Container 			
										 데이터베이스 서버 및 타 서버와 연동 
										 다양한 비즈니스 로직을 처리하여 
										 동적인 컨텐트를 클라이언트에게 제공하는 웹 어플리케이션 서버 
										 
Web Container :  java web 기술인 Servlet 과 JSP 가 실행되는 환경을 제공 


- 우리는 현재 WAS 제품군 중에서 Apache Tomcat 9 를 사용한다 

- 자바 웹 어플리케이션 개발 환경 설정 
	1. tomcat/conf/server.xml 에서  port 를 변경 ,  get 요청 방식 한글처리를 위해 URIEncoding="utf-8"
	   을 명시 
	2.  tomcat/conf/context.xml 에서  reloadable="true" 을 줘서  java class 가 변경되어 컴파일 될 때 
		자동으로 서버에 배포되도록 설정 
		  
HTML : web document 컨텐트 담당
CSS : web document 디자인 스타일 담당
JavaScript : web document 행위 담당 

ECMAScript 표준을 준수하는 스크립트 언어 
ECMA 인터내셔널 : 정보 통신 표준을 제정하는 표준화 기구 

ES5 (ECMA5, 2009)	: 변수 선언 var -> 중복선언 가능 , Function level scope 		   
ES6 (ECMA6, 2015)  : 변수 선언 let -> 중복선언 불가 , Block level scope 
						   const 상수 , arrow function (화살표 함수) 등이 새롭게 추가 

서버가 웹문서를 응답하여 브라우저가 수신하면 						   
HTML을 읽는다 -> HTML 을 파싱한다 -> DOM Tree를 생성한다 
-> Render 트리가 생성(css와 결합)->브라우저에 표시된다					   	

DOM ( Document Object Model ) 
: javascript에서  web document 의 요소(element : 버튼, div, span ..)를 제어하기 위한 
  프로그래밍 인터페이스를 제공 
  웹브라우저 지원 
  HTML 문서(document) 요소를 계층적으로 지원 ( DOM Tree ) 
  하여  button, div , span 과 같은 요소들을 제어하고 조작하기 위한 함수를 제공 

Client Side :  html , css , javascript
Server Side : Servlet / JSP

**Servlet 기본 개념**
- Servlet :  java web programming 기반 기술 
			  MVC 의 Controller 역할을 담당 
			  java class 기반으로 개발
			  
 - JSP : Java Server Page , 동적으로 웹페이지를 제작하기 위한 템플릿 엔진 기술 
 		   MVC 의  View 역할을 담당 	
 		   html 기반으로 개발 		   

  - MVC (  Model2 Architecture 의 MVC 패턴 , Web MVC ) 
   	 Model :  비즈니스와 데이터 액세스 로직을 담당
   	 View : 응답을 전담, 클라이언트에게 동적인 화면을 제공  
     Controller : 제어자의 역할, 요청을 분석 , 모델과 연동 , 적절한 View 를 선택해 응답시킴


   - Http 요청 방식 request method   GET / POST 
   	 get 방식 : 정보 조회용 , url 에 정보가 노출 , 전송 용량에 제한
   	 
   	 post 방식 : 정보 전송용 , url 에 정보가 노출되지 않는다 ,
   	              http request body 영역에 저장되어 전송 , 용량에 제한 x 

  **내일 할 주요 목차**
  ==========토론============================================
  get 방식과 post 방식 특징 ==> 면접에 자주 나오므로 토론  :  Servlet  doGet() doPost() 
  query string 이란? 
  
  http response status code 404 ,405, 500,200 의미 ?
  Servlet 과 JSP가 무슨 차이? 
  =========================================================== 
   
  Servlet 과 Form 연동 
  HttpServletRequest 와 HttpServletResponse 
  어노테이션 기반 설정과 xml 기반 설정 
  Servlet LifeCycle ==> 미리 찾아보면 좋습니다 
  ServletConfig 와 ServletContext ==> 미리 찾아보면 좋습니다 
  Cookie 와 Session ==> 미리 찾아보면 좋습니다 


 **webstudy5-Servlet-Basic-xml-config**
 
 Java Web Application 설정 방식 
 1. xml 설정 방식 : WEB-INF\web.xml => DD ( Deployment Descriptor )
 					  설정과 코드가 분리 => 유지보수성 
 2. annotation 설정 방식 :  컴파일과 실행에 영향을 주는 의미있는 주석 
 							   소스 코드 상에 설정정보를 기술 => 생산성 
 	서블릿 3.0 에서 지원  						   
 							   
 1.  web.xml 설정의 예 
 <!--  어플리케이션으로 접속하면 제공될 기본 메인 화면    -->
  <welcome-file-list>
    <welcome-file>home.html</welcome-file>
  </welcome-file-list>
  <!--  xml 기반 서블릿 설정 --> 
  <servlet>
    <servlet-name>HelloServlet</servlet-name>
    <servlet-class>step1.HelloServlet</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>HelloServlet</servlet-name>
    <url-pattern>/hi</url-pattern>
  </servlet-mapping>							   					  
                               
2. annotation 설정의 예 
					url-pattern 
@WebServlet("/hi")
public class HelloServlet extends HttpServlet{}

**webstudy6-Servlet-Form**
URL 
http://localhost:8888/webstudy6-Servlet-Form/GetMethodTestServlet?name=이강인&address=마요르카
--분석--
http : protocol 
localhost : domain name  ex) naver , daum, google 
8888 : port 
webstudy6-Servlet-Form : web application 명 / context path 
GetMethodTestServlet : web application 의 url pattern  웹프로그램 경로명 
? : 구분자 ( url-pattern 과 query string 을 구분 ) 
name=이강인&address=마요르카 : query string 
name 과 value 쌍으로 전달 
& : query string 여러개 보내기 위한 구분자 

참고) Servlet / JSP 에서는  request.getParameter(name) 으로 value를 리턴받는다 
**Query String**
url 주소로 클라이언트 데이터를 서버에 전달하는 방법 

** html form 과 Servlet 연동 **
Client Browser															Server ( Servlet or JSP )   
method : request method 요청방식 										@WebServlet(url-pattern)  or web.xml 
action : 처리할 서버 프로그램 url 										public void doPost(request,response){
<form method="post" action="url-pattern">                           String name=request.getParameter("userName");
<input type="text" name="userName">
<button type="submit">전송</button>									}
</form>

--------------------------------------------------------------------------------
Web Container 의 역할 :  Java Web Program(Servlet/JSP) 을 개발하고 실행하는 환경을 제공 
							 Servlet 과 JSP 의 LifeCycle(생명주기) 관리 
							 

- 서블릿 계층구조 ( Servlet Hierarchy)

최상위 인터페이스 
<<interface>> 
  Servlet  -  init() , service() , destroy()  와 같은 abstract method 가 선언되어져 있다
   
  implements  
<<abstract class>>
  GenericServlet - Servlet Interface를 implements 하는 abstract class  
  					  프로토콜에 독립적인 클래스 
  					  일반적인 서버 차원에서 가져야 하는 기능을 물려주고 
  					  자식 차원에서 구현해야 하는 service() 메서드는 abstract로 선언해
  					  구현을 강제한다 	
  extends 
 <<abstract class>>
  HttpServlet   - GenericServlet을 상속받는 abstract class
  					 Http Protocol 에 최적화된 멤버를 자식에게 물려준다 
  					 일반적으로 개발하는 Servlet 과 JSP ( 이후 Spring 의 DispatcherServlet )
  					 는 이 클래스를 상속받는다 
  					    
**Servlet API 설계방식의 특징**  					 
  : 일반적인 웹어플리케이션 개발 진영에서는  
    표준화된 Servlet API(ServletRequest,ServletResponse,HttpSession 등 ) 을 이용해 개발,
    실제 동작은 그 인터페이스들을 implements 한 WAS 의 
    다양한 제품군( ApacheTomcat, JBoss, WebLogic 등 ) 들이 동작된다 
    
    다양한 WAS 제품군들과 관계없이 표준화된 단일한 방법으로 자바 웹개발이 가능 -> 생산성 향상 
    구축된 Web Application 이 다른 WAS 로 배포되어도 영향이 최소화 -> 유지보수성 향상   					 
  					 

**Servlet LifeCycle**			
 서블릿(jsp) 의 생명 주기 , Web Container가 관리한다 
 대표적인 라이프 사이클 메서드는 최상위 인터페이스 Servlet 에 선언된 abstract method 
 init() -> service() -> destroy()
 
 init() :  web container로부터 ServletConfig 객체를 전달받음 ( ServletConfig 는 이후 공부예정 ) 
          현 서블릿의 초기화 작업을 담당  
          처음 서블릿 실행시 단 한번 호출되어 실행됨  
          
 service() : web container로부터  request, response 를 전달받아 실행 
			  client 요청시마다 매번 호출되어 실행됨 
			  
 destroy() : web container로부터 해당 서블릿이 해제or소멸 직전에 단 한번 호출되어 실행됨 
 
 예)   클라이언트가 검색을 위해 FindProductServlet 에 접속해 서비스를 제공받았다 
 	   100명의 클라이언트가 접속해 서비스 받았다고 가정하고 
 	   WAS 에 생성된 	FindProductServlet 의  
 	   객체수 : 1개
 	   init() : 1번
 	   service() -> doGet() or doPost() : 100번 
 	   destory() : WAS 종료 직전에 1번 실행 
 	   
 	  browser 				WAS
 	  
 	  client  --request-->   is loaded? --no-->   Servlet 객체 생성    
 	   								|						|
 	   								|					  init() 실행  : 단 한번 실행 
 	   							  yes 						|
 	   							    | 					    |
 	                                --------->      service() 실행 : 매 요청시마다 실행
 	                                                        |
 	   						<--response--------							
 
 								destroy() : WAS 종료 직전에 한번 실행 
 
 
**내일 할 주요 목차**
- ServletConfig , ServletContext , ServletContextListener 
- Cookie 와 Session 

**오늘 복습 사항**
면접 :  Servlet Life Cycle  ->  Servlet interface 의 라이프 사이클 관련 메서드 3개 설명 
									생성부터 소멸까지의 흐름을 설명 
공부 :  서블릿 계층 구조 
구현 :  form  과 서블릿 연동  webstudy6 의 step1 , step2 와 대응되는 서블릿을 잘 분석 									

 **LifeCycle 관련 설정**
 <load-on-startup>1</load-on-startup> 
 Servlet LifeCycle에 의해 특정 서블릿이 최초 요청될 때 해당 서블릿 객체 생성 후 
 init() 호출되어 초기화가 실행된 후 서비스 된다 
 시스템에서 중요한 역할을 수행하는 서블릿을 최초 요청시가 아니라 
 웹어플리케이션이 처음 실행될 때 객체 생성 및 init 실행되어 초기화 작업이 되도록 설정하는 것이 
  <load-on-startup>1</load-on-startup> 설정이다  
( 예 - 호텔이 오픈할때 중요한 역할을 하는 호텔프론트(서블릿)는 미리 초기화되어 
        고객이 오면 바로 서비스할 수 있도록 준비해야 한다 )  
 
 **ServletConfig와 ServletContext**
 ServletConfig : 서블릿 설정 정보 객체 
 				   서블릿 객체당 하나 생성
 				   init(ServletConfig) 이 웹컨테이너에 의해 호출되어 질 때 전달받음 
 				   ServletConfig는 ServletContext의 참조값을 내장하고 있음 
 				   또한 필요시 외부에서 해당 서블릿의 설정정보를 전달하고자 할 때 사용할 수 있음 
 				   ex)  서블릿 - 사원  ,  ServletConfig - 사원증 
 				   
 ServletContext : 웹어플리케이션내의 모든 웹프로그램들(Servlet or JSP)이 공유할 수 있는 객체 				   
 					 웹어플리케이션 당 하나 생성 
 					 Web Application 이 처음 시작될 때 ServletContext 객체가 생성되고 
 					 종료 직전에 ServletContext 객체가 소멸된다 
 					 

 **ServletContextListener**
 : Application LifeCycle Listener 
   웹어플리케이션 시작 시점과 종료 시점의 이벤트를 감지하여 
   시작 시점에 필요한 초기화 작업과 
   종료 시점에 필요한 작업을 정의해 실행할 수 있다    					 
 
ServletContextListener의 abstract method  					 
1. contextInitialized(ServletContextEvent sce)
    웹어플리케이션이 처음 시작되는 시점의 이벤트를 감지해 
    특정 작업을 수행할 수 있음 ==> 주로 Security 작업을 한다 
2. contextDestroyed(ServletContextEvent sce)							   							  
 	또한 웹어플리케이션이 종료 전에 이벤트를 감지해 
 	특정 작업을 수행할 수 있음 ==> 필요시 백업 및 로깅 작업을 한다  					 


 **webstudy8-cookie-session**
 Cookie 와 Session 이 필요한 이유?  
 HTTP ( HyperText Transfer Protocol ) 는 Stateless 한 특징을 가지기 때문
 Stateless : 서버의 서비스를 받는 사용자 정보를 유지하지 않는 속성 
 
 HTTP 특성 : Stateless 
 				상태 유지하지 않는다 
 				접속한 사용자 정보를 유지하지 않는다 
 				많은 사용자에서 서비스해야 하는 서버는 
 				자원을 효과적으로 사용하기 위해 요청에 대한 응답이 되면 
 				연결을 해제하고 사용자 정보를 유지않도록 기본 설계되어 있다 
 
 사용자 정보를 필요시 유지해야 할 경우 ( 인증기반 커뮤니티 or SNS or 장바구니 or 주문,결제 등 )   
 Cookie 와 Session 과 같은 기술이 필요하다 
 
 Cookie 와 Session 과 같은 기술이 필요한 이유 ? 
 Http 는 Stateless 한 특성 , 즉 사용자 상태 정보를 유지하지 않는다 
 사용자 상태 정보를 유지해야 할 필요가 있을 때  cookie 와 session 과 같은 기술을 이용한다 
 
 세션관리 : 사용자 정보를 일정 조건동안 유지 
 
 상태정보 : 사용자의 의사 또는 어떤 자격을 가지는 지에 대한 정보 
 			 ( ex - 오늘 하루 팝업창을 보지 않겠다는 의사 ,  네이버 카페에 로그인하여 회원 자격이 있는 사용자 )
 			  
 
 사용자 정보를 유지하는 방식 중 
 1. Cookie 
 	클라이언트 측에 상태 정보를 저장 
 	저장 용량에 제한 ( 4kb ) 
 	저장 데이터 타입의 제한 -> 문자열만 가능 
 	
 	Cookie 생성시 유효시간을 설정 , 
 	유효시간을 설정하지 않으면 해당 브라우저 실행시까지만 유효 
 	
 	step1. 클라이언트가 접속하면 SetCookieServlet이  쿠키 생성해 응답시에 전달해 클라이언트 측에 저장시킴
 	
 										WAS 
 	client browser --request-->   SetCookieServlet
 										Cookie 생성 (name,value)
 										cookie.setMaxAge(30); // 30초간 쿠키가 유효 
 										response.addCookie(cookie);
 					 <--response-- 
 					 
 	step2.  클라이언트가 접속하면 	GetCookieServlet이 실행 ,  request로부터 cookie 정보를 가져와 
 			 SetCookieServlet에서 저장한 쿠키 정보를 화면에 출력해본다 			 
 					 					WAS	
 	client browser --request-->   GetCookieServlet
 										request.getCookies() : Cookie[] 
 										cookies[i].getName() / cookies[i].getValue() 를 이용해 쿠키 정보 출력 				 
 					 <--response--
 		
 2. Session(HttpSession)
    서버 측에 사용자 상태 정보를 저장 
    저장 용량 및 데이터 타입에 제한이 없다
    로그인, 로그아웃시 주로 세션이 이용된다 ( 세션은 내부적으로 쿠키를 이용한다 ) 
    
    세션 유효시간 
    1. WAS 에서 설정된 지정 유효시간 내에 재접속이 없을 때 세션 만료  
    2. 브라우저 종료시 세션 만료 
    3. 로그아웃 실행시 세션 만료 
 
    세션 관련 주요 메서드 
    - request.getSession() or request.getSession(true) 
      기존 세션이 있으면 기존 세션을 반환하고 
      없으면 새로 생성해 반환 
    
    - request.getSession(false) 
      기존 세션이 있으면 기존 세션을 반환하고 
      없으면 null 반환    
 
    - session.setAttribute(name,value); 
      세션에 저장할 정보를 name과 value 쌍으로 저장 
    
    - session.getAttribute(name) : Object 
      세션에 저장된 정보를 name으로 반환 
      
    - session.invalidate(); 
      세션을 무효화 시킬때 사용  ( 로그아웃시 사용 )   
      
    - Session 과 Cookie의 관계 
    세션은 내부적으로 jsessionid 라는 쿠키를 사용 
    								 LoginServlet
    client browser --request--> request.getSession();  세션 생성  
      				 
      				 
      				 <--response--
      	jsessionid name cookie가 저장 
     
     재접속 							CafeServlet
     client browser --request-->  	request.getSession(false) 
      									: getSession 메서드 내부에서 client측의 
      									  jsessionid cookie를 확인해서 
      									  해당 Session 이 서버에 존재하는 지 여부에 따라
      									  존재하면 기존 세션 반환 
      									  존재하지 않으면 null 반환 
      									  
      						




 					 
**JSP 기본**

JSP : Java Server Page 
		서버 측에서 웹페이지를 동적으로 생성하는 기술 
		HTML에 자바 코드를 삽입하는 형식으로 개발 -> 동적인 웹페이지 구현에 적합
		Template Engine ( 자바 서버사이드 웹페이지 생성 기술 ) -> jsp , thymeleaf 등
		MVC 의  View 역할을 담당 		
		 					 
 JSP 기본 문법 
 1) JSP 주석  <%--   --%>
 2) Scriptlet 스크립틀릿 <%    %>    java code 삽입시 사용 , service계열 메서드 내에 코드로 삽입 
 3) Expression 출력  <%=  %>    out.print() 로 생성,  출력시 사용
 4) Declaration 선언 <%!  %>  멤버 변수 또는 메서드를 정의할때 사용 
 5) Directive 지시 <%@  %>  웹컨테이너에게 현 페이지의 정보를 알리는 역할( import , encoding , errorPage 등)
 
**JSP LifeCycle**
JSP는 HttpServlet의 자식 클래스 subclass 인 HttpJspBase class를 상속받은 서블릿클래스로 
웹컨테이너에 의해 생성된다 
JSP는 HttpServlet의 자식(sub) 클래스이므로 라이프 사이클은 서블릿과 동일하다 
차이점은 jsp 는 최초 요청시  .jsp 를 통해 웹컨테이너가 .java -> .class 로 생성한 후  실행하는 점이다

client browser --request-- is loaded? --no--  .jsp -> .java 생성 -> .class 로 컴파일 
									|			 									|
 								  yes  											   객체 생성
 								  	|												init(ServletConfig) 최초 한번 실행 
 								  	|												|
 								  	|--------------------------->       service(request,response) 매요청시마다 실행 
 								  	
 								  				destroy() 	: 서비스 해제 직전 한번 호출 											
 								  			
 
 **JavaScript DOM 과 BOM**
 DOM : Document Object Model  문서객체모델
 		 javascript에서 web document의 element 를 제어하기 위한 
 		 API 를 제공 
 BOM : Browser Object Model , 브라우저객체모델 
 		 javascript 가 브라우저와 소통하기 위해 만들어진 객체 모델 
 		 web document의 element 를 제외한 웹 브라우저 창에 포함된
 		 객체 요소들을 의미함 ( window 속성에 속하고 , document 가 아닌 
 		 window 를 제어 ) 			 
 		  
   **Model 1 Architecture**
   
   Software Architecture : 소프트웨어 아키텍쳐(설계양식)는 
                               소프트웨어 구성 요소(component or java bean)들 사이의 관계를 표현한 것임 
   
   초기 웹개발 방식 
   
       jsp     <--->  Database
   샘플예제 : step1-jsp-db.jsp    
        
       
   Model 1 설계방식 
   	
   	  jsp     <--->  java beans <---> Database 
   	  
   	샘플예제  step2-model1.jsp   <---> MemberDAO <--> Database   
   	  
   	Model1 설계방식에서 jsp 역할 :  client 에게  리스트 또는 입력양식(form) 과 같은 웹화면 제공
   										 client 의 request 를 분석 
   										 request에 따른 java bean or component 과 연동 
   										 연동 결과에 따라 적절한 응답을 제공 
   										 
   	Model1 에서 Java Beans 역할 :  business logic 과 data access logic 을 담당 
   										bean == component 와 동일한 의미 
   										
   	Model1 -> Model2 MVC 아키텍쳐 변화의 특징 
   	:  Model 1 에서 담당하는 jsp 의 역할 분화 :  Controller와 View로 분화 
   	
    Model2 MVC Architecture 
    			Controller(Servlet)
    View(jsp)	 					
    								Model(java beans)
    
    Model 2 Architecture 의 핵심적인 디자인 패턴이 MVC Design Pattern 이다
    Web MVC or Model2 MVC or MVC 로도 불린다 
    이후 SpringMVC 라는 스프링의 핵심 기술의 근간을 이루는 설계방식이 Model2 이다 
    
 **Controller에서 View로 제어를 이동하는 방식 : forward 와 redirect **
 1) forward 방식 :  request와 response가 유지되면서 제어가 이동되는 방식 
    Web Container 상에서 이동되므로 클라이언트(브라우저) 측은 이동여부를 알 수 없다 ( URL 상의 변경이 없음 ) 
    클라이언트가 재동작 즉 재요청(새로고침) 할 경우 request와 response가 유지되므로 기존 동작이 반복된다 
    주로 정보 조회(select)시 이용된다 
    Model 과 연동 결과를 request에 저장 ( ex - request.setAttribute(name,value) 해서 View에 정보를 공유 )
    View는 클라이언트에게 응답시에 연동 정보를 request로부터 반환(ex- request.getAttribute(name))받아 정보를 제공    

    Controller forward 의 예 ) 
    MemberDAO dao=new MemberDAO();
    MemberVO vo=dao.findMemberById(id);
    request.setAttribute("vo",vo);
    request.getRequestDispatcher(view name).forward(request,response);   
    
 2)  redirect 방식: 응답시 클라이언트에게 이동할 url을 지정하여 
                      클라이언트가 이동하게 하는 방식 
                      기존 request와 response 는 유지되지 않는다
                      재요청시 기존 동작은 반복되지 않는다 
                서버 상태변경( insert , delete , update 를 통한 데이터 변경 )에 적합      
    
 **Singleton Design Pattern**
: 시스템 상에서 단 하나의 객체(인스턴스)를 생성하고 여러 곳에서 공유해 사용하기 위한 디자인 패턴    								 					     
 ( spring 에서 객체를 만들어서 사용하는 기본 방식 )   	 
 
 1. private constructor : 외부 ( 다른 클래스 ) 에서 객체 생성을 못하게 막는다 
 2. static 변수 초기화 시점에 인스턴스 생성 : 클래스 로딩은 단 한번 이루어지고 static 이 한번 로딩되므로 
 												  이러한 특성을 이용해 heap 영역에 객체 생성하고 객체 주소값을 
 												  meta space 에 저장한다 
 3. public static method 로 외부에 공유 :  class loading 시점에 단 한번 생성한 객체의 주소값을 
 											   여러 곳에서 사용하게 하기 위해 public static 메서드로 공유한다    
 webstudy12 에 적용해본다  	  
   	  
** EL ( Expression Language ) ** 
JSP 버전이 상향되면서 추가된 스크립트 언어
기존 Scriptlet tag의 표현식 ( <%= %> ) 의 업그레이드 된 버전 ( ${ } ) 
JSP 속성영역 ( request, session, application(ServletContext) ) 에 저장된 객체의 
property 를 출력하는 용도 
EL을 이용하면 별도의 import , Object Casting 절차 필요없이 바로 출력이 가능 , 
다양한 연산 및 자동 형변환이 된다 
JSTL 과 연동이 가능 
EL은 Model 객체의 get계열 메서드와 is계열의 메서드에만 접근 가능 


** JSTL( Jsp Standard Tag Library ) ** 
View(jsp) 에서 자주 사용하는 기능 ( 조건문 , 반복문, 자료구조의 데이터 표현 )을 
미리 구현해 놓은 태그 라이브러리 
EL 과 함께 사용해서 View 로직과 데이터를 표현 

환경설정 : WEB-INF\lib\jstl-1.2.jar 파일을 위치시킨다 

다운로드 경로 : https://mvnrepository.com/artifact/javax.servlet/jstl/1.2  	  
   	      
 **webstudy16-MVC-member-login**   
요구사항 :   비로그인상태에서는 로그인폼을 제공 
 			  로그인상태에서는 회원정보 제공하고 
 			  인증이 되어 있을 때 서비스 되는 메뉴를 노출 
 			  로그아웃 버튼을 제공 
 
  
 회원 로그인 , 로그아웃  work flow 
 
 index.jsp ------------>  LoginServlet <------->  MemberDAO <--> DB 
request method : post        
비로그인 상태에서는			로그인 성공(id,pass 일치시)
로그인 폼을 제공        	    세션 생성하고 회원정보를 세션에 공유(인증 정보) 
							    index 로 이동 ( redirect ) 
							    

							    로그인 실패(id,pass 일치하지 않을경우) 
       							login-fail.jsp 에서 
       							로그인 실패 alert 후 index 로 이동 ( redirect ) 
       							
로그인 상태에서는 
전주에 사는 조규성님 
로그아웃버튼 					  -------->  LogoutServlet					
주소로 회원검색(이미 구현되어 있음)        	 session.invalidate() : 세션 무효화 						
       											 로그아웃 처리후 
       											 index ( redirect ) 
       											 
 사전 학습 및 체크 포인트 
 :  Model2 MVC 상에서 세션 활용 , JSP 에서 세션을 어떻게 활용하는지 단위테스트로 확인 
    test/test-session1.jsp , test/test-session2.jsp 
    SessionTestServlet(세션 생성 및 정보할당) , SessionTestServlet2 (세션 무효화)       											

로그인 개발단계 
1. sql test : id password에 일치하는 회원 정보를 조회 
2. src/test/java : TestUnitLogin 에서 DAO 의 login(id,password) : MemberVO 를 테스트 
3. LoginServlet 을 구현 
   index jsp 와 연동 
   로그인 실패 확인
   로그인 성공 확인
    
로그아웃 개발단계    
1. LogoutServlet 구현 
2. index 에서 로그아웃 확인  			  
 			        											
 **webstudy17-MVC-FrontController-Pattern-ver1**
 
 - Front Controller Design Pattern
 : 모든 클라이언트의 요청을 하나의 진입점으로 통합하여 처리하는 설계 패턴 
 
   웹 어플리케이션 서비스의 공통 정책을 일관성 있게 효과적으로 처리할 수 있다
   -> 인코딩 , 인증 , 예외처리 , 데이터 수집 등        											
       											
 
   기존 Web MVC 구조     											
   client    -----  FindCustomerByIdServlet
   client    -----  RegisterCustomerServlet 
   					  그 외 서비스들이 많다고 가정 
   					  
   서비스가 증가할수록 전체적인 공통 정책(인코딩,보안,예외처리 정책등..)에 대한 제어가 어려워진다     											
   FrontController Design Pattern 을 적용해  모든 클라이언트의 요청을 하나의 진입점으로 모아서 공통 정책을 수행하도록 
   구조를 개선 
   
    webstudy17-MVC-FrontController-Pattern-ver1   		    											
       											
    client   --findbyid--   FrontControllerServlet    											
       											
    client    --register--         doDispatch() 
    
    
    클라이언트 측에서는 						FrontControllerServlet  에서는
    hidden command 로 요청을 하고 			command 를 분석해 어떤 서비스를 요청하는 지 알아내어 	   											
       											서비스를 한다 
       											
    -> 하나의 Front Controller 서블릿에서 여러 고객의 다양한 요청을 구분하기 위해 아래와 같이 
    	hidden 방식을 이용한다 
    예 )  client : hidden tag 는 화면에 나타나지 않되 서버에 데이터를 전송하는 용도의 html form 요소 
    	  <input type="hidden" name="command" value="register">			
    		   
    	  FrontControllerServlet 에서는 
    	  String command=request.getParameter("command");
    	  if(command.equals("register"){ // client가 보낸 command 정보로 요청을 구분 
    	  		//등록 서비스를 제공 
    	  }	   											
     
   위와 같은 구조로  클라이언트의 다양한 요청을 하나의 진입점을 모아서 처리했다 
   현 Ver1 시스템에 대한 토론     											
   개선점 :   FrontControllerServlet 의 doDispatch() 에 업무가 비대해짐 
   			   -> 업무를 분리해야 함	  											
       							
   refactoring 방안 : 메서드별로 컨트롤러 로직을 분리해서 전담시킴 
   						FrontControllerServletVer2 에서 적용해봄 
   						
   토론 : 메서드로 분리해서 Ver1 보다는 응집도가 높아졌지만 이후 서비스가 증가될 경우 
   		  FrontControllerServletVer2 class 자체가 비대해져 
   		  생산성 및 유지보수성이 높지 않음 
   		  
   refactoring 방안 : 클래스별로 컨트롤러 로직을 분리해 전담시킴 		  					
   						     				
   Ver3 으로 업데이트 
   
   토론 :  FrontControllerServlerVer3 과  FindCustomerByIdController , RegisterController로
   		   분리해 공통 정책은 Front 에서 , 개별 서비스 컨트롤러 로직은 각 Controller class에서
   		   담당하게 구성 
   		   -> FrontControllerServlet 과 개별 컨트롤러와의 높은 결합도는 개선 사항임 
   		       실제 컨트롤러 구현 클래스의 내부 구현부를 확인해서 
   		       각 메서드 별로 호출해야 하는 단점 
   		       
   refactoring :  인터페이스를 통한 계층구조 형성 => 다형성이 지원되도록 프로그램을 개선 
   			
   Ver4 는  별도의 프로젝트(webstudy17-MVC-FrontController-Pattern-ver4)에서 
   refactoring 을 해본다 			
   	
   *webstudy18-MVC-FrontController-Pattern-ver4-inst2*
   전체 구성은  src/test/java  아래 front.mdj  class diagram 을 참조한다 
   
   ver4 구조 
   1. FrontControllerServlet( spring : DispatcherServlet ) 
      : 모든 클라이언트 요청의 단일한 진입점의 역할 , 공통 정책을 효과적으로 수행 
        공통 정책 - 인코딩 , 보안(인증) , 예외처리 , 로깅 .. 		           				
       				
   2. Controller 
   		: 개별 컨트롤러 로직 구현체의 상위 인터페이스 
   		      				
       	  컨트롤러 구현체들을 계층구조화 ( 캡슐화 ) 하여 
       	  사용하는 측(FrontControllerServlet) 이 단일한 방식으로
       	  다양한 컨트롤러 구현체들을 실행할 수 있게 한다 	
       	  => 캡슐화하여 다형성 지원 or 계층구조화 하여 다형성 지원 
    
    3. 개별 Controller 구현 객체 : 실제 클라이언트의 구체적인 요청을 처리하는 
    								  담당 컨트롤러 로직을 정의하는 객체     	  
       	  
     
    ver4 에 대한 토론 
    :  FrontControllerServletVer4 에서  요청에 대한  개별 컨트롤러 객체 생성부가 
       서비스가 증가할수록 역할에 부담   	  
       => Front 는 공통 정책에 집중 ( 높은 응집도 ) 해야 하므로 
       	   컨트롤러 객체 생성을 전담하는 팩토리 클래스(객체)를 별도로 분리
       	   => 응집도가 높아짐 , 또한  FrontControllerServletVer5 과 개별 컨트롤러의 결합도는 낮아짐   	  
       	  
       	  
    *webstudy19-MVC-FrontController-Pattern-ver5*
               	  
   1. FrontControllerServlet( spring : DispatcherServlet ) 
      : 모든 클라이언트 요청의 단일한 진입점의 역할 , 공통 정책을 효과적으로 수행 
        공통 정책 - 인코딩 , 보안(인증) , 예외처리 , 로깅 .. 		           				
   
   2. HandlerMapping : 담당 컨트롤러(handler:담당자)를 연결하는 역할  
                        개별 컨트롤러 객체 생성을 전담하는 클래스 
    					FrontControllerServlet 이 공통 정책에 집중 ( 응집도를 높임 )
    					FrontControllerServlet 과 개별 컨트롤러들과의 결합도를 낮춘다
    					( 컨트롤러 객체들이 변경되어도 영향이 없음 )
   
       				
   3. Controller 
   		: 개별 컨트롤러 로직 구현체의 상위 인터페이스 
   		      				
       	  컨트롤러 구현체들을 계층구조화 ( 캡슐화 ) 하여 
       	  사용하는 측(FrontControllerServlet) 이 단일한 방식으로
       	  다양한 컨트롤러 구현체들을 실행할 수 있게 한다 	
       	  => 캡슐화하여 다형성 지원 or 계층구조화 하여 다형성 지원 
    
    4. 개별 Controller 구현 객체 : 실제 클라이언트의 구체적인 요청을 처리하는 
    								  담당 컨트롤러 로직을 정의하는 객체    	
    								  ( ex - 고객검색업무 , 고객등록업무 )   
       	  
    ver 6 :  서비스의 수가 늘어날수록 HandlerMapping 의 create 메서드 객체 생성 작업이 
    		  계속 추가 되어야 한다 
    		  => 컨트롤러 객체 생성을 자동화 할 수 있는 방안 
    		  	  => command 에 따라 동적으로 인스턴스를 생성할 수 있도록 
    		  	  	  Reflection API 를 적용해본다 
    		  	  	  	   	   		
       		 내부구조 개선(refactoring)의 목표 : HandlerMapping 의 컨트롤러 객체 생성을 자동화 
       		 									    Reflection API : 런타임시 동적으로 객체 생성하고 제어하기 위한 기술 
       		 									    -> spring 에서 객체 생성할 때 사용하는 기술 
       		 									    단위테스트 : src/test/java
       		 									    후
       		 									    적용  		
       				
     ver7   요청 url pattern :  *.do 을 지원하도록 업데이트를 한다 
     
     		ver6 까지는  사용자의 요청 사항을 구분하기  hidden 을 이용 
     		<form action="FrontControllerServletVer6">
     		<input type="hidden" name="command" value="Find">
     		</form>
     		
     		위의 방식은 요청시마다 hidden command 정보를 매번 생성해야 했다 
     		-> url-pattern 상에서 command 정보를 전송한다면 
     		    더 생산성있는 개발이 가능 
     		ver7 
     		<form action="Find.do">
     		</form>    
     		    
 **webstudy23-MVC-FrontController-member-inst2**
 
 MVC 와 FrontController , Singleton Design Pattern 을 적용해 회원관리 어플리케이션을 구현
 주요기능 :  아이디로 회원검색 , 주소로 회원검색 , 로그인 , 로그아웃 , 회원정보수정 , 회원가입(아이디 중복확인)  
 
 개선점 :  현 프로그램 구조에서는 
			회원에 대한 입력 작업이 모두 마무리되고 
			회원가입을 눌러 전송했을때 
			아이디 중복확인 여부를 알게 된다 
			고객의 편의성 측면에서 개선점이 된다 
			=> ajax 를 적용해서 고객이 희망하는 아이디를 입력하는 즉시
				사용가능여부를 실시간으로 알려주고 
				사용가능상태에서만 회원가입이 가능하도록 처리   
		      
		    => 이를 위해 webstudy24 에서 ajax study 를 한 후 
		        회원아이디 중복확인 기능을 ajax 방식으로 업데이트 (webstudy23 복제 후 webstudy25에서 반영 )  	 	
						    
   **webstudy24-ajax-basic**
   
   AJAX : Asynchronus Javascript And Xml 
   			비동기 자바스크립트 통신 
   			요청에 대한 응답을 페이지가 아니라 필요한 데이터(text or xml or json)로 응답받는다
   			-> 페이지 응답이 아니라 데이터로 응답받는다 
   			
   			동기적 통신 : 클라이언트가 요청하면 서버가 응답할때까지 대기 
   			비동기적 통신 : 클라이언트가 요청, 클라이언트는 자신의 작업을 진행하다가 서버가 응답하면 업데이트    		    
     		    
   XML 과 JSON : Ajax 통신시 사용하는 데이터 형식
					  구조화된 데이터 송수신을 위해 xml과 json을 이용한다 
			          2005년 이후 초기에는 xml 을 이용했으나 최근에는 주로 json 을 이용한다 
			          
   JSON : JavaScript Object Notation  
             자바스크립트 객체 표기법
             Ajax 통신시 구조화된 데이터를 송수신하는 용도로 사용된다 
             경량이고 높은 생산성이 장점이다 
             
    **webstudy25-MVC-FrontController-member-ajax-checkId**         
    
    ajax 를 이용해 아이디 중복 확인을 체크해서 
    사용가능할때만 회원가입 할 수 있도록 기능을 개선          
             
    FrontController Design Pattern 적용 환경에서 
    Ajax 응답의 반복적인 작업을 줄이기 위해 
    Ajax 응답을 전담하는 AjaxViewServlet 을 추가 구현
    개별 컨트롤러는 Ajax 응답시에는 필요한 String or JSON 정보를 
    request 에 responsebody name 에 저장하고 
    AjaxView 라는 viewName으로 리턴한다 
    ex) FindMemberByIdAjaxController 에서 확인한다     
        회원검색을 ajax 방식으로 처리해봄 ( index.jsp ,   FindMemberByIdAjaxController )
        
    => register-member.jsp 의 회원가입폼에서 아이디 중복확인을 
        아이디를 입력하는 시점에 ajax 방식으로 처리한다 
        사용가능한 상태가 아니면 회원가입 전송이 되지 않도록 하고 
        사용가능한 아이디를 입력한 상태이면 회원가입 처리되도록 한다 
        
        아이디는 4자이상 10자 이하로 한정하는 조건 
        4자 미만 또는 10자 초과일 경우에는 아이디 입력 텍스트 옆에
        아이디는 4자 이상 10자 이하이어야 합니다 라고 메세지를 보여준다 
        
        4자 이상 10자 이하일 경우에 
        입력한 아이디를 ajax 방식으로 서버에 전송해 db의 회원 테이블 아이디 정보와 비교
        아이디가 존재하면 사용불가(빨간색글씨) 
        아이디가 존재하지 않으면 사용가능(파란색글씨) 
        
        만약 사용가능 상태가 아닌 경우에 회원가입 전송버튼을 누르면 
        아이디 중복확인 인증을 받으세요 alert 후 전송시키지 않는다 
        
   **webstudy26-MVC-Front-Ajax-DBCP**
   - Web MVC + Front Controller + Singleton Pattern 
   - 개발환경 : jdk 1.8 , db -> oracle  , was -> apache-tomcat , 형상관리 -> git , cloud -> aws ec2 
   - 적용기술 : Java SE , DB SQL, JDBC , html / css / javascript(Ajax, JSON) , Servlet , JSP(jstl) 
   - 주요 적용 디자인패턴 :  MVC , FrontController , Singleton 
   
   현재까지 공부했던 내용을 복습차원에서 다시 한번 구현해본다 
          
   *DBCP*
    DataBase Connection Pool , DataSource 
    : 컨넥션들을 pool에 미리 생성 , 빌려주고 반납   
         
    : database connection 을  생성, 소멸시키는 방식이 아니라 
      미리 pool에 connection 들을 생성해놓고 빌려주고 반납받는 형식으로
      시스템 성능을 향상시키는 기술      
        
    DataSource :  javax.sql.DataSource 
    				다양한 dbcp 객체들을 하나의 방식으로 제어하기 위한 인터페이스 
    				
    BasicDataSource : apache tomcat 에서 제공하는 dbcp 구현체 , javax.sql.DataSource 인터페이스의 하위 구현체 
    
    **webstudy27-MVC-member-path-test**
    경로연습1  member 디렉토리 아래에 회원관리 관련 jsp 를 배치한 후 
                회원관리 전체 기능이 동작되도록 변경 
    경로연습2  member/path-test.jsp 에서  front-controller-pattern.png
    			이미지가 나오도록 경로를 설정해서 html code를 작성 
    경로연습3  요구사항에 따라  member 아래의 path-test.jsp 가 
    			member/admin/path-test 로 위치가 변경되어야 한다 	
    
    <img src="../picture/front-controller-pattern.png" width="800">			
    <form action="../FindMemberById.do" method="get">
    
    위와 같이 상대 경로로 설정을 해서 경로연습2에서는 잘 동작되었으나 
    경로연습3 처럼 디렉토리가 변경되면 해당 jsp 들의 경로들이 다수 변경되어야 한다 
    ==> 해결방안 : jsp EL 
                     ${pageContext.request.contextPath}
                     을 이용하면 
                     한번 경로 설정을 하면 디렉토리 구조가 변경되어도 동적으로 
    				 현재 어플리케이션 명(컨텍스트 패스)을 기준으로 찾아가므로
    				 별도의 변경 작업이 필요없게 할 수 있다 		
    				 
    				 member/path-test2.jsp 와 
    				 member/admin/path-test2.jsp 에서 확인을 한다 			
    			          
    **webstudy28-bootstrap**
    bootstrap :  반응형 웹 개발을 위한  css framework 
    
    반응형 웹 : 다양한 기기에 알맞게 최적화된 웹화면을 제공 
    
    CSS 의 @media query 미디어 쿼리 - html5 css3 에 의해 지원되는 반응형 웹을 위한 기술 
    										 다양한 기기 화면의 종류와 크기에 따라 적절한 디자인 제공
    
    
    
    
    
    
    
    				    
        
        
        
        
        
        
        
        
        
        
        
        
        
               
             
             
             
             
              
   			 		  
					   	
	  		    
     		    
     		    
     		    
     		    
     		
     		
     		
     		
     		
     		
     		
     		
     		
     		
     		
     		
     		   				
       				
       				
       							
       							
       							
       							
       							
       							
       							
       							
       
       
       
       
       
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 					 
 					 
 					 
 					 
 					 
 					 
 					 
 					 
 

 
 
 
   













	
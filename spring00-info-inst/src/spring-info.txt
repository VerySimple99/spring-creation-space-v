**spring**

주요목차 
- IOC / DI 
- AOP 
- Logging
- MyBatis(SQL Mapper)
- SpringMVC(Spring Legacy) , Ajax(JSON)
- jUnit(TDD)
- SpringBoot
- Thymeleaf
- REST
- Interceptor
- Spring Security 
- JPA(ORM)
======================
- MSA 
- React 와 SpringBoot 

--------------------------------------------

용어정리 
library : 라이브러리 , 재사용 가능한 프로그램들의 모음 
jar : 자바프로그램 압축 확장자 (springboot application을 deploy하기 위해 압축 )
war : 자바 웹어플리케이션 확장자 
component : 독립적 기능단위로 부품화 되는 요소 
			   Bean => 자바 컴포넌트 , 스프링 컨테이너에서 관리하는 객체를 Bean이라고 함
API : Application Programming Interface  응용 프로그램을 개발하기 위해 제공하는 인터페이스 
Framework :  사전적 의미로는 틀  (  frame 틀  + work 일 ) => 일을 잘하기 위한 틀을 제공 
				응용 프로그램의 기반을 제공 
				반완전한 어플리케이션 => 제공 가능한 최대한 지원 => 비즈니스 로직에 집중  
				
Spring Framework 				
			자바 어플리케이션의 설계,구현,테스트,운영에 대한 Infrastructure(기반)를 제공 
		    다양한 컴포넌트와 디자인 패턴을 제공 
		    
		    Spring IOC/DI,AOP,MVC,SpringBoot,SpringSecurity,SpringCloud 등의 기술 지원과 
		    jUnit,MyBatis,Hibernate 등과 같은 프레임워크와의 통합을 지원한다     


**IOC/DI**
- IOC 개념 : 소프트웨어 설계 원리이자 디자인 패턴 
  Inversion Of Control , 역 제어 , 제어의 반전 (역행) 
  Bean 제어를 IOC 컨테이너에 위임 
  필요시 직접 만드는 기존의 제어 방식이 아니라 필요로 하는 요소를 IOC 컨테이너에 위임 
  컴포넌트(Bean)를 구성하는 인스턴스 라이프 사이클과 의존 관계 연결 처리를 IOC  컨테이너에 위임  
  why?  loose coupling  결합도를 느슨하게 한다 
         참고) 결합도란 모듈간의 상호 의존도 , 결합도가 낮다는 것은 유지보수성, 확장성이 높아진다  
  
  

- DI 개념 : 디자인 패턴 
   Dependency Injection , 의존성 주입  	
   필요로 하는 의존성( bean or component ) 을 주입(injection) 을 통해 확보 
   즉 IOC 를 DI 기법을 통해 실현한다 
   
- DL 
   Dependency Lookup  , 의존성 검색     
   필요로 하는 의존성( bean or component ) 을 검색(lookup) 을 통해 확보 
   즉 IOC 를 DL 기법을 통해 실현한다 

- Maven : 프로젝트 관리 도구 , 빌드툴 
            프로젝트에서 필요로 하는 라이브러리를 일괄적으로 관리 ( 원격저장소에서 로컬저장소로 다운로드받아 사용 )
			pom.xml ( project object model : maven 설정 파일 ) 을 형상관리한다
			프로젝트 실행 파일을 maven 으로 생성 ( jar or war ) 해  Deploy 배포한다 

- 어제 내용 복습 
   Framework :  일을 잘하기 위한 틀을 제공 
                   설계 구현 테스트 운영 인프라
   Spring Framework :  자바 어플리케이션에 대한 설계,구현,테스트,운영 전반을 지원하여
                           비즈니스 로직에 집중하게 기반을 제공 
                           IOC , DI , AOP , MVC , SpringBoot, JUnit , MyBatis , JPA 등의 기술을 지원함 
   Maven or Gradle : project build tool , 의존라이브러리관리 , 실행파일을 생성해 deploy                        

   IOC : Inversion Of Control  제어의 역전 
   		  bean (객체 or Component) 의 라이프사이클을 컨테이너에 위임해 관리    
          => Loose Coupling 
          
   DI : Dependency Injection 의존성 주입        
          
  **Spring(spring bean) LifeCycle**
  Bean : 스프링 컨테이너가 관리하는 객체(컴포넌트)
  
  Spring Container 실행 -> Bean 생성 & DI -> 초기화 콜백 @PostConstruct : bean 생성 직후 실행되는 init 메서드  
  -> 서비스 : Bean 기능 실행 -> 소멸 콜백 @PreDestroy : 소멸(서비스해제) 직전 실행되는 destroy 메서드 -> 종료 
 
 * 콜백 : 나중에 다시 호출될 함수나 메서드 
 
 
  🌟 스프링 빈 라이프사이클 상세 설명 (면접 답변 예시)
"스프링 빈 라이프사이클은 스프링 컨테이너(IoC 컨테이너)가 빈(Bean)을 생성하고, 
초기화하며, 사용하고, 최종적으로 소멸시키는 전 과정에서 발생하는 일련의 단계를 의미합니다. 
개발자는 이 라이프사이클의 특정 시점에 원하는 로직을 삽입하여 빈의 동작을 제어할 수 있습니다.

주요 단계는 다음과 같습니다:

빈 정의 로딩 (Bean Definition Loading):
스프링 컨테이너가 XML 설정 파일, Java 어노테이션(@Configuration, @Component 등), 
또는 Java 코드를 통해 빈의 정의(클래스 정보, 의존성 등)를 읽어들입니다.

빈 인스턴스 생성 (Bean Instantiation):
컨테이너가 빈 정의를 바탕으로 new 연산자를 사용하듯이 
해당 클래스의 인스턴스를 생성합니다. (기본적으로는 기본 생성자 호출)

의존성 주입 (Dependency Injection):
생성된 빈의 속성(프로퍼티)에 필요한 의존성(다른 빈)들을 주입합니다. 이는 생성자 주입, Setter 주입, 필드 주입 등 다양한 방식으로 이루어집니다.

초기화 콜백 (Initialization Callbacks):
의존성 주입이 완료된 후, 빈이 사용될 준비를 마치기 위해 초기화 작업을 수행하는 단계입니다. 이 시점에 개발자가 정의한 초기화 로직이 실행됩니다.
초기화 콜백을 지정하는 방법은 주로 세 가지가 있습니다:
@PostConstruct 어노테이션: JSR-250 표준 어노테이션으로, 메서드에 붙여 초기화 시점에 실행됩니다. (JDK 9+ 환경에서는 jakarta.annotation-api 의존성 필요)
InitializingBean 인터페이스: afterPropertiesSet() 메서드를 구현하여 초기화 로직을 정의합니다. (스프링 전용 인터페이스)
XML 설정의 init-method 속성: XML 빈 정의에 초기화 메서드 이름을 지정합니다.

빈 사용 (In Use):
초기화가 완료된 빈은 이제 애플리케이션에서 요청에 따라 사용될 준비가 됩니다. 개발자는 이 빈의 메서드를 호출하여 비즈니스 로직을 수행합니다.

소멸 콜백 (Destruction Callbacks):
스프링 컨테이너가 종료되거나, 스코프가 짧은 빈(예: request, session 스코프)이 수명이 다했을 때, 빈이 소멸되기 직전에 정리 작업을 수행하는 단계입니다. 이 시점에 개발자가 정의한 소멸 로직이 실행됩니다.

소멸 콜백을 지정하는 방법은 주로 세 가지가 있습니다:
@PreDestroy 어노테이션: JSR-250 표준 어노테이션으로, 메서드에 붙여 소멸 시점에 실행됩니다. (JDK 9+ 환경에서는 jakarta.annotation-api 의존성 필요)

DisposableBean 인터페이스: destroy() 메서드를 구현하여 소멸 로직을 정의합니다. (스프링 전용 인터페이스)
XML 설정의 destroy-method 속성: XML 빈 정의에 소멸 메서드 이름을 지정합니다.
빈 소멸 (Bean Destruction):

소멸 콜백이 완료되면, 컨테이너는 해당 빈의 인스턴스를 메모리에서 제거합니다.

이러한 라이프사이클 관리를 통해 스프링은 개발자가 객체의 생성, 의존성 주입, 초기화, 소멸 등의 복잡한 과정을 직접 관리할 필요 없이 비즈니스 로직에만 집중할 수 있도록 도와줍니다. 특히, @PostConstruct와 @PreDestroy는 간편하게 초기화/소멸 로직을 추가할 수 있어 많이 사용됩니다."
  
  
  
  
  
  **Spring 설정 방식**
  XML , Annotation , Java Config 설정 방식이 있다 
  xml + Annoation 조합 또는 Annotation + Java Config 조합으로 설정 된다 
  
  XML 설정 방식 => 소스코드와 설정 분리 
  Annotation 설정 방식 => 소스 코드 상에서 설정이 기술 
  
  **Spring Annotation Config**
  컴포넌트 계열 어노테이션 
  @Component : Spring IOC Container에게 해당 클래스가 bean 생성 대상임을 알리는 어노테이션 
                   bean 으로 라이프 사이클 관리가 되고 Singleton으로 운영된다 
                   @Component : 컴포넌트 계열 어노테이션 상위 타입 , 일반 컴포넌트 클래스에 명시, bean으로 생성,관리됨 
   				   @Component 계열 하위 어노테이션 
   				   @Controller : MVC 중 Controller or Presentation Layer 에 명시
   				   @Repository :  Data Access Object or Persistence Layer 에 명시 
   				   @Service : Business Layer 에 명시  	                
   설정 어노테이션 
   @Configuration :  해당 클래스가 Spring 설정 클래스임을 Spring Container에게 알리는 어노테이션 
   
   @ComponentScan(base package) : 지정한 base package 하위 클래스들을 탐색해 
   								          bean 생성 ,관리 , DI 처리한다  

   DI(Dependency Injection) 관련 어노테이션
   : 스프링 컨테이너로부터 의존성 주입하고자 할때 적용하는 어노테이션 
   DI 는 constructor , field , setter 모두 가능하다 => 권장되는 방식은 constructor  
   @Autowired : 의존성 bean 을 타입으로 검색해 주입.  field , constructor , setter 모두 가능 
   				   @Qualifier(bean name) : 동일한 타입의 여러 bean 이 존재할때 bean name을 명시해 주입할 수 있음 
   				   
   @Resource , @Inject 등의 어노테이션이 있음 				   


   **생성자를 통한 DI를 권장하는 이유**
   - 의존성 확보가 보장된다 ( 엔진 없는 자동차가 생성될 수 없다. 앙꼬없는 찐빵이 만들어 질 수 없다 )
     review : 생성자를 명시하는 이유는 객체 생성시 필요한 초기화 작업을 하기 위해 
               ( 자동차를 생성하기 위한 초기화 작업은 엔진 생성 , 찐빵 생성 초기화 작업은 앙꼬 ) 
     setter , field injection 은 의존성 즉 필요로 하는 객체를 생성해 주입하지 않아도 
     객체 생성이 가능 
     NPE(NullPointerException) 을 사전에 방지할 수 있다
   
   - 단위 테스트에 용이 
      의존 관계를 가지는 다양한 객체를 생성해서 생성자에 주입해 테스트 해볼 수 있다 
      
   - 객체를 불변으로 만들 수 있다 => final 로 처리할 수 있다 ( 이후 적용 예정 ) 
     setter 또는 field injection 은 final 로 처리할 수 없고 
     오직 Constructor injection 만 가능 
     처음 객체 생성시 생성자에서 주입받은 bean 즉 의존성이 이후 변경 불가능하도록 처리할 수 있다 
     
     => why? 의존성 확보 보장 , 불변성 보장 , 단위 테스트 용이 
     
     
     Spring IOC 컨테이너의 자동 주입 기준 (생성자 주입 시)
     Spring 4.3 버전부터 단일 생성자에 한해서 @Autowired 어노테이션을 생략해도 
     자동으로 의존성을 주입해 주도록 변경되었습니다. 
     이것은 Spring이 개발의 편의성을 높이고, 생성자 주입을 권장하는 디자인 철학을 반영한 것입니다.

적용 기준:

단일 생성자 (Single Constructor): 클래스에 생성자가 하나만 존재하는 경우에 해당합니다. 
Spring IOC 컨테이너는 이 유일한 생성자를 "의존성을 주입받을 곳"으로 자동으로 인식하고, 해당 생성자의 매개변수에 해당하는 빈(Bean)들을 찾아 주입합니다.

여러 개의 생성자: 만약 클래스에 생성자가 두 개 이상 존재한다면, 
Spring은 어떤 생성자를 통해 의존성을 주입해야 할지 알 수 없습니다. 
이 경우에는 명시적으로 @Autowired 어노테이션을 사용하여 어떤 생성자를 사용할지 지정해 주어야 합니다.
     
final 키워드의 장점 (생성자 주입 시)
final 키워드를 생성자 주입과 함께 사용하는 것은 매우 권장되는 방식이며, 여러 가지 중요한 장점을 가집니다.

불변성(Immutability) 보장:

final 필드는 일단 초기화되면 값을 변경할 수 없습니다. 
생성자를 통해 의존성을 주입받은 후에는 greetingService가 다른 객체를 참조하도록 변경될 수 없다는 것을 보장합니다.
이는 객체의 상태가 예측 가능하고 안정적이라는 것을 의미하며, 
특히 멀티스레드 환경에서 동시성 문제를 줄이는 데 도움이 됩니다. 
객체가 생성된 후에는 변경되지 않으므로, 여러 스레드가 동시에 접근해도 데이터 불일치 문제가 발생할 가능성이 낮아집니다.

안정성 및 오류 방지:
final 필드는 반드시 선언 시 또는 생성자 내에서 초기화되어야 합니다. 
초기화되지 않으면 컴파일 오류가 발생합니다.
이는 개발자가 의존성을 주입하는 것을 잊거나 누락하는 경우를 컴파일 시점에 즉시 파악할 수 있게 해줍니다. 
런타임에 NullPointerException이 발생하는 것을 미리 방지할 수 있습니다.
"이 객체는 이 의존성이 없으면 동작할 수 없어!"라는 것을 명확하게 선언하는 것과 같습니다.

의도 명확화 및 가독성 향상:
final 키워드를 사용하면 해당 필드가 객체의 생명주기 동안 단 한 번만 설정되고 
그 이후로는 변하지 않을 것임을 코드적으로 명확히 전달합니다.

이는 코드의 의도를 분명히 하고, 다른 개발자가 코드를 읽을 때 
"아, 이 greetingService는 한 번 주입되면 변경되지 않는구나"라고 쉽게 이해할 수 있게 합니다.

테스트 용이성 (Testability):
불변 객체는 테스트하기 더 쉽습니다. 객체의 상태가 변경될 가능성이 없으므로, 
테스트 케이스를 작성할 때 다양한 상태 변화를 고려할 필요가 줄어듭니다.
생성자 주입은 테스트 시에 Mock 객체나 실제 구현체를 쉽게 주입하여 단위 테스트를 용이하게 해줍니다. 
final이 이를 더욱 확고히 합니다.
결론적으로, final 키워드와 생성자 주입을 함께 사용하는 것은 
Spring 개발에서 권장되는 모범 사례(best practice)입니다. 
이는 코드의 안정성, 가독성, 그리고 유지보수성을 크게 향상시켜 줍니다.    
     
     
     
     
 🌱 Spring Boot란 무엇인가?
실생활 비유: 원룸 vs 일반 아파트
전통적인 Spring (일반 아파트):
입주할 때 가구, 가전제품, 인터넷, 전기, 수도 등을 일일이 설치
모든 설정을 개발자가 직접 해야 함
복잡하고 시간이 많이 소요
Spring Boot (원룸 풀옵션):
입주하자마자 모든 것이 준비되어 있음
필요한 설정들이 자동으로 완료
바로 사용 가능!
****************************************************************************
 ## **Spring Boot의 핵심 철학**

### **1. Convention over Configuration (관례 우선 설정)**

**실생활 비유**: 자동차 운전

- 모든 자동차의 액셀러레이터는 오른쪽, 브레이크는 왼쪽
- 매번 새로 배울 필요가 없음
- **관례**를 따르면 **설정**이 불필요

**Spring Boot에서:**

- `src/main/java`: Java 소스 코드 위치 (관례)
- `application.properties`: 설정 파일 위치 (관례)
- `8080` 포트: 기본 웹 서버 포트 (관례)
 ### **2. Auto Configuration (자동 설정)**

```java
// Spring Boot가 자동으로 해주는 일들
// 1. 웹 서버 설정 (Tomcat)
// 2. 데이터베이스 연결 설정
// 3. JSON 변환기 설정
// 4. 로깅 설정
// 5. 보안 기본 설정
// ... 수백 가지 설정들을 자동화!

```

### **3. Standalone (독립 실행)**
**이전 방식:**
- WAR 파일 생성 → 톰캣 서버에 배포 → 실행
**Spring Boot:**
```bash
java -jar myapp.jar  # 이것만으로 웹 서버까지 함께 실행!

```
 
 
🔍 @SpringBootApplication 어노테이션 해부하기     
 // @SpringBootApplication은 실제로 이것과 같습니다:
@SpringBootConfiguration  // = @Configuration : 역할: "이 클래스는 설정 클래스입니다"
@EnableAutoConfiguration // 필요한 설정들을 자동으로 해줘!
@ComponentScan // 이 패키지부터 시작해서 모든 컴포넌트를 찾아줘   
     
     
 @SpringBootConfiguration  // = @Configuration : 역할: "이 클래스는 설정 클래스입니다"    
// 예를 들어 이런 설정들을 할 수 있어요
@SpringBootApplication
public class MyApplication {

    @Bean  // 수동으로 Bean을 등록할 수 있음
    public String welcomeMessage() {
        return "Spring Boot에 오신 것을 환영합니다!";
    }     
     
  실생활 비유: 아파트 관리사무소
아파트(애플리케이션)의 모든 설정을 관리하는 곳   
     
     
 ### **2 @EnableAutoConfiguration**
**역할**: "Spring Boot야, 필요한 설정들을 자동으로 해줘!"    
 // Spring Boot가 자동으로 감지하고 설정하는 것들:
// - classpath에 web 라이브러리가 있으면 → 웹 서버 자동 설정
// - classpath에 H2 데이터베이스가 있으면 → DB 자동 설정
// - classpath에 JPA가 있으면 → JPA 자동 설정    
  **실생활 비유**: 스마트홈 시스템
- 새로운 기기를 연결하면 자동으로 인식하고 설정   
### **3. @ComponentScan**

**역할**: "이 패키지부터 시작해서 모든 컴포넌트를 찾아줘!"

```java
// 자동으로 찾아서 Bean으로 등록하는 것들:
@Component    // 일반적인 컴포넌트
@Service      // 비즈니스 로직
@Repository   // 데이터 접근
@Controller   // 웹 컨트롤러

```
**실생활 비유**: 아파트 입주자 명단 작성
- 각 호수를 돌아다니며 거주자 정보를 자동으로 수집     
     
**************Spring Legacy 와 Spring Boot 의 Spring Container****************************************************************     
🎯 핵심 요약: 연관성의 본질
완전히 동일한 목적, 다른 방법
java// Legacy: 수동 조립
AnnotationConfigApplicationContext ctx = 
    new AnnotationConfigApplicationContext(AppConfig.class);

// Spring Boot: 자동 조립
SpringApplication.run(MyApp.class, args);

// 🔥 결과: 둘 다 Spring ApplicationContext 생성!
진화의 3단계

XML 시대: ClassPathXmlApplicationContext
Annotation 시대: AnnotationConfigApplicationContext
Spring Boot 시대: SpringApplication.run() (내부적으로 ApplicationContext 생성)

교육적 연결점
java// 🎓 학생들에게 이렇게 설명
"Legacy에서 여러분이 직접 했던 일들을
Spring Boot가 SpringApplication.run() 안에서 자동으로 해주는 것입니다!"

// 직접 했던 일:
// - ApplicationContext 생성
// - 설정 클래스 등록  
// - Bean 생성 및 주입
// - 생명주기 관리

// Spring Boot가 자동으로 하는 일:
// - 위의 모든 것 + 자동 설정까지!     
     
Spring Legacy vs Spring Boot: 애플리케이션 컨텍스트 생성 방식 비교
🎯 핵심 연관성: 둘 다 Spring Container 생성하는 방법
본질적으로 같은 일을 하는 두 가지 방법
Spring Legacy 방식:
java// 🔧 수동으로 Spring Container 생성
AnnotationConfigApplicationContext ctx = 
    new AnnotationConfigApplicationContext(AppConfig.class);

// 컨테이너에서 Bean 가져오기
MyService service = ctx.getBean(MyService.class);
service.doSomething();

// 사용 후 컨테이너 종료
ctx.close();
Spring Boot 방식:
java// 🚀 자동으로 Spring Container 생성 + 관리
@SpringBootApplication
public class MyApp {
    public static void main(String[] args) {
        SpringApplication.run(MyApp.class, args);
        // 🔥 내부에서 ApplicationContext 생성하고 모든 것을 자동 관리!
    }
}     
     
각 세대별 특징
1세대 (XML):

모든 Bean 정의를 XML에 명시
컨텍스트 생성과 관리 모두 수동

2세대 (Annotation):

Java 기반 설정으로 타입 안정성 확보
여전히 컨텍스트 생성/관리는 수동

3세대 (Spring Boot):

자동 설정으로 최소한의 코드
컨텍스트 생성부터 관리까지 모두 자동     
*****************************************************************************     
**CommandLineRunner란?**     
Spring Boot 애플리케이션가 완전히 준비되면
CommandLineRunner)이 자동으로 작동하여
우리가 작성한 코드을 실행시킵니다.    
     
- **배치 작업**: 매일 밤 데이터 정리 작업
- **초기 데이터 설정**: 애플리케이션 시작 시 기본 데이터 생성
- **시스템 점검**: 시작 시 DB 연결, 외부 API 상태 확인     
     
@SpringBootApplication
public class MyApplication implements CommandLineRunner {

    public static void main(String[] args) {
        System.out.println("1. main 메서드 시작");
        SpringApplication.run(MyApplication.class, args);
        System.out.println("3. main 메서드 종료");
    }

    @Override
    public void run(String... args) throws Exception {
        System.out.println("2. CommandLineRunner 실행!");
        System.out.println("   - Spring 컨테이너 준비 완료");
        System.out.println("   - 모든 Bean 생성 완료");
        System.out.println("   - 이제 우리 코드 실행 차례!");
    }
}
***********ServletContextListener 와 CommandLineRunner******************
실행 시점 비교
ServletContextListener:
웹 컨테이너 시작 → 웹 애플리케이션 로드 → contextInitialized() 실행 → 서비스 시작
CommandLineRunner:
JVM 시작 → Spring Boot 시작 → Spring Container 준비 → run() 실행 → 서비스 시작
// 🎓 교육적 설명
"ServletContextListener.contextInitialized()를 기억하시나요?
웹 애플리케이션이 완전히 준비된 후에 실행되는 메서드였죠.

CommandLineRunner.run()도 똑같은 개념입니다!
Spring Boot 애플리케이션이 완전히 준비된 후에 실행되는 메서드예요.

차이점은:
- ServletContextListener: 웹 컨테이너 환경에서만
- CommandLineRunner: 모든 Spring Boot 환경에서"

핵심 공통점:

✅ 초기화 완료 시점 실행
✅ 애플리케이션 시작 로직 배치
✅ 한 번만 실행되는 특성
✅ 후크(Hook) 메서드 성격

차이점:

🔄 환경: Servlet Container vs Spring Boot
🔄 복잡성: 수동 설정 vs 자동 설정
🔄 범위: 웹 전용 vs 범용
     
     
// 🔄 Servlet → Spring Boot 마이그레이션
// Before (Servlet)
// 🔍 두 방식의 실행 순서 비교

    
    // Servlet 방식
    public class ServletInitializer implements ServletContextListener {
        @Override
        public void contextInitialized(ServletContextEvent sce) {
            System.out.println("1️⃣ Servlet 컨텍스트 초기화 완료");
            System.out.println("   - 웹 애플리케이션 준비됨");
            System.out.println("   - 서블릿 등록 완료");
        }
    }
    
    // Spring Boot 방식
    @SpringBootApplication
    public class SpringBootInitializer implements CommandLineRunner {
        @Override
        public void run(String... args) throws Exception {
            System.out.println("2️⃣ Spring Boot 애플리케이션 초기화 완료");
            System.out.println("   - Spring Container 준비됨");
            System.out.println("   - 모든 Bean 생성 완료");
        }
    }

     
     
     
  ***************************************************************
  스프링 부트 로깅 기초
1. 로깅이란 무엇인가?
로깅은 애플리케이션의 실행 과정을 기록하는 것입니다. 마치 일기를 쓰듯이 프로그램이 무엇을 했는지 남겨두는 거예요.
실생활 예시

병원 차트: 환자의 상태 변화를 기록
비행기 블랙박스: 비행 중 모든 상황을 기록
애플리케이션 로그: 프로그램의 동작 과정을 기록

IT 개발 현장에서는?

문제 해결: 오류가 발생했을 때 원인 파악
성능 모니터링: 시스템이 얼마나 빠르게 동작하는지 확인
사용자 행동 분석: 어떤 기능을 많이 사용하는지 파악
보안 감시: 비정상적인 접근 시도 감지

2. System.out.println vs 로깅
java// ❌ 좋지 않은 방법
System.out.println("사용자가 로그인했습니다: " + username);

// ✅ 좋은 방법
logger.info("사용자가 로그인했습니다: {}", username);
System.out.println의 문제점

레벨 구분 불가 (중요한 것과 덜 중요한 것을 구분 못함)
파일 저장 어려움
성능에 좋지 않음
운영 환경에서 끄기 어려움

3. 로깅 레벨의 이해
로깅 레벨은 중요도에 따른 분류입니다:
ERROR > WARN > INFO > DEBUG > TRACE
(높음)                        (낮음)

ERROR: 심각한 오류 (시스템이 멈출 수 있는 상황)
WARN: 경고 (문제가 될 수 있지만 동작은 계속)
INFO: 일반 정보 (중요한 비즈니스 로직의 흐름)
DEBUG: 디버깅 정보 (개발자가 문제를 찾을 때 필요)
TRACE: 매우 상세한 정보 (모든 실행 과정)
  
핵심 포인트
✅ 기억해야 할 것들

Logger는 클래스마다 하나씩 생성하여 사용
적절한 로깅 레벨 선택 (INFO는 운영환경, DEBUG는 개발환경)
{}를 활용한 파라미터 바인딩 사용으로 성능 향상
예외 발생 시 스택트레이스 함께 기록
의미있는 메시지 작성으로 문제 해결 도움

🚀 실무 팁

로그인/로그아웃은 INFO 레벨
데이터베이스 쿼리는 DEBUG 레벨
예외 발생은 ERROR 레벨
성능이 중요한 부분은 TRACE 레벨  


내부 구성 
스프링 부트의 로깅 구성
기본 구조
SLF4J (인터페이스) 
    ↓
Logback (구현체) ← 스프링 부트 기본값
자동 포함되는 의존성
스프링 부트 스타터에는 다음이 자동으로 포함됩니다:

spring-boot-starter-logging
slf4j-api (인터페이스)
logback-classic (구현체)
logback-core (핵심 라이브러리)
  ***************************************************************   
     
     
     
     
     
     
     
     
     
     
     
     
     **AOP**
     Aspect Oriented Programming  관점 지향 프로그래밍 
     Aspect => 관점   Core Concern 핵심관심사 + Cross Cutting Concern 횡단관심사 or 공통관심사 
     시스템을 핵심관심사항과 공통관심사항으로 구분해 분석,설계,구현,운영한다 
     공통,반복 작업을 피하고 효과적인 유지보수가 가능 => 응집도를 높이고 결합도 낮춘다 
     =>응집도를 높임: core 담당자는 core에 집중 , cross cutting 공통관심사(ex-보안,로깅,트랜잭션..) 담당자는 자신의 역할에 집중 
     =>결합도를 낮춤: 공통 관심사 로직이 변경될 때 기존 코드는 수정이 필요하지 않고 해당 AOP 공통관심사 로직만 변경하면 됨                    
     spring pdf 의 그림 참조 (aop 적용전과 후 그림을 확인) 

      Core Concern(핵심관심사) : 시스템 업무 목적에 해당하는 주요 로직 ( ex- 회원관리, 결제 등 )
      Cross Cutting Concern(횡단 or 공통관심사) : 시스템 여러 부분에 걸쳐 적용되는 공통 로직 
      													(ex- 트랜잭션 , 보안 , 로깅 등 )
   - AOP 동작원리 
     Proxy Design Pattern 
     Proxy 는 대리인을 의미 , 대신해서 Cross Cutting Concern 공통 로직을 수행 
     사용하는 측과 서비스를 제공하는 측의 매개자로서 Proxy 객체가 역할을 담당 
     ( ex - 아이유팬  <--> 아이유 매니저(cross cutting) <--> 아이유(core) )   													

  - Logging : Logging 관련 구현체 ( Log4j , Logback.. ) 
               Slf4j : Logging 관련 구현체의 추상 계층 
           
   로깅 : 시스템 동작에 관한 정보를 제공하는 기록
          주로 시스템 실행 정보 및 성능,에러에 대한 정보를 저장, 제공 
           참고 ) System.out.println() -> 개발 및 운영에 대한 로그 레벨을 지정할 수 없고 
            파일과 같은 곳에 저장할 수도 없어 정보를 유지할 수 없음
            -> Logging 관련 기술에 필요    

      자바 진영에서 사용하는 로깅 프레임워크는 대표적으로 Log4j , Logback 등이 있음 
     
      로깅 프레임워크 특징 
      설정파일( logback.xml , log4j.xml ) 에서 패키지별로 레벨 설정이 가능 
      지정한 레벨 등급 이상의 로그만 기록하고 저장하는 방식
      파일 로깅, 용량설정 , 실행시 설정변경 적용 등 여러 기능이 제공       

      로그레벨 (log level)    :  만약 로그레벨을 INFO 로 설정하면  ERROR,WARN,INFO 가 로깅 
      ERROR
      WARN
      INFO
      DEBUG
      TRACE  

       - SLF4J : Simple Logging Facade -> Facade 는 사전적 의미로 표면 ,겉면 -> 인터페이스를 의미 
        SLF4J 는 로깅 퍼사드로서  여러 로깅 라이브러리 구현체들 ( Log4j , Logback 등 ) 을 
        하나의 통일된 방식으로 사용할 수 있는 방법을 제공 , 캡슐화 
        SLF4J 방식으로 개발하면 이후 로깅 구현체가 변경되어도 별도의 수정이 없다는 장점이 있음         
           
  **MyBatis Framework**
   영속성 계층 프레임워크  Persistence Layer Framework => SQL Mapper Framework ( 자바 어플리케이션과 SQL 을 연결 )
   DAO ( Data Access Object ) 를 효율적으로 개발 
   데이터베이스 연동 자바 프로그램을 효율적으로 개발하고 운영할 수 있게 지원한다          
           
           ## MyBatis 핵심 구조

### **2.1 전체 아키텍처**
 ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Java Code     │    │   XML Mapper    │    │   Database      │
│                 │    │                 │    │                 │
│ UserMapper.java │◄──►│ UserMapper.xml  │◄──►│ MySQL/Oracle    │
│                 │    │                 │    │                 │
│ - selectUser()  │    │ - <select>      │    │ - SELECT query  │
│ - insertUser()  │    │ - <insert>      │    │ - INSERT query  │
└─────────────────┘    └─────────────────┘    └─────────────────┘
          
           
   핵심 컴포넌트        
 A. Mapper Interface (Java)  
 // MyBatis의 핵심: 인터페이스만 정의, 구현체는 MyBatis가 자동 생성
@Mapper
public interface UserMapper {
    User selectUser(Long id);        // 메서드명 = XML의 id
    int insertUser(User user);       // 반환타입 = 영향받은 행 수
    List<User> selectAllUsers();     // 컬렉션 반환 가능
}
          
B. XML Mapper (SQL 정의)           
<!-- namespace = Mapper Interface의 완전한 클래스명 -->
<mapper namespace="com.example.mapper.UserMapper">
    <!-- id = 인터페이스의 메서드명과 일치 -->
    <select id="selectUser" parameterType="long" resultType="User">
        SELECT * FROM users WHERE id = #{id}
    </select>
</mapper>
           
## 3. 파라미터 매핑 (`#{}` vs `${}`)
### **3.1 `#{}` - PreparedStatement (권장)**           
 <!-- 안전한 매핑: SQL Injection 방지 -->
<select id="selectUser" resultType="User">
    SELECT * FROM users WHERE id = #{id}
    <!-- 실제 실행: SELECT * FROM users WHERE id = ? -->
</select>
3.2 ${} - Statement (주의 필요)
<!-- 직접 문자열 치환: 위험할 수 있음 -->
<select id="selectUsersByColumn" resultType="User">
    SELECT * FROM users ORDER BY ${columnName}
    <!-- 실제 실행: SELECT * FROM users ORDER BY name -->
</select>
동적 테이블명, 컬럼명
     
3.3 복합 파라미터 처리          
// @Param 어노테이션으로 명확한 파라미터 명시
List<User> selectUsersByAgeRange(@Param("minAge") int minAge,
                                @Param("maxAge") int maxAge);
 <select id="selectUsersByAgeRange" resultType="User">
    SELECT * FROM users
    WHERE age BETWEEN #{minAge} AND #{maxAge}
</select>
          
           
 **Spring MVC**

   Spring Framework 기반 java web application 구현을 위한 기술 

   

   - Spring MVC 의 주요 디자인 패턴 

     MVC Design Pattern ( 실세계의 예 : 식당 - 주방 , 메뉴판 or 음식  , 키오스크 ) 
      Model : 비즈니스 로직과  데이터 액세스 로직 
      View :  클라이언트로의  response를 전담 
      Controller :  request 분석 , Model 연동 , View 선택해 응답 

     Front Controller Design Pattern    
         모든 클라이언트의 요청을 한 곳을 집중시켜 공통 정책을 수행
         인코딩 , 보안(인증과 인가) , 예외처리와 같은 공통 정책을 효과적으로 수행할 수 있다 
         ( 실세계의 예 :  콜센터 or 호텔 프론트 ) 
         

     - Spring MVC  요청과 응답까지의 실행 흐름 
       client 가 request 하면 DispatcherServlet 가 동작되고 실제 컨트롤러를 연결할 
       HandlerMapping 이 컨트롤러 구현체를 연결하고 HandlerAdapter 가 컨트롤러 메서드를 
       실행한다   클라이언트에게 응답할 방식을 ViewResolver가 제공하여 
       그에 따라 클라이언트에게 View(jsp/ajax-json/thymeleaf 등) 를 응답한다      

    

    Spring MVC 의 주요 컴포넌트 
    - DispatcherServlet : Front Controller 역할을 담당 , Spring 설정을 로딩 - IOC / DI 처리를 지원
    - HandlerMapping : 요청을 처리할 컨트롤러를 연결 ( RequestMappingHandlerMapping ) 
    - HandlerAdapter : Controller를 실행하는 역할 , 
                           컨트롤러 메서드에서 필요로 하는 데이터를 가공해 전달해줌 
                           ( request.getParameter() 를 대행하여 vo 로 전달, 자동형변환 등을 지원 ) 
     - ModelAndView : Model 과 연동한 정보 -> request.setAttribute(name,value) 
         와 View 정보 -> /WEB-INF/views/ok.jsp  에서 view name : ok                      
     - ViewResolver : 클라이언트에게 응답할 방식을 지원 
       jsp or thymeleaf or ajax json 등의 방식을 지원      

        
    SpringMVC의 주요 어노테이션 
    @Controller : 컨트롤러 로직을 처리하는 클래스 
    @RequestMapping : 요청 url과 controller method를 mapping 
    @GetMapping : get 방식만 지원 - 아니면 http response status code : 405
    @PostMapping : post 방식만 지원   - 아니면 http response status code : 405
    @ResponseBody : ajax 응답을 위한 어노테이션 
    @RestController : Rest API Service를 위한 컨트롤러 -> @Controller + @ResponseBody           
           
           
 Spring Boot 3.4 + Thymeleaf 컨트롤러 핵심 요소  
주요 어노테이션
클래스 레벨 어노테이션           
@Controller              // 뷰를 반환하는 MVC 컨트롤러 (Thymeleaf 사용 시 필수)
@RequestMapping("/base") // 클래스 전체에 공통 URL 경로 설정       
                
 메소드 레벨 어노테이션	   
@GetMapping("/path")     // GET 요청 매핑
@PostMapping("/path")    // POST 요청 매핑 (폼 전송)
@RequestParam           // 쿼리 파라미터 바인딩
@PathVariable           // URL 경로 변수 바인딩
@ModelAttribute         // 폼 객체 바인딩

  
 주요 컴포넌트
데이터 전달 컴포넌트 
Model                   // 템플릿에 데이터 전달 (가장 기본)
ModelAndView           // 뷰 이름 + 데이터를 함께 관리
RedirectAttributes     // 리다이렉트 시 데이터 전달 
          
HttpServletRequest     // 요청 정보 접근
HttpServletResponse    // 응답 제어
HttpSession           // 세션 관리          
          
   
**PRG(Post-Redirect-Get) 패턴**          
PRG(Post-Redirect-Get) 패턴은 웹 개발에서 중복 제출(duplicate submission)을 방지하기 위한 디자인 패턴이에요. 사용자가 폼 데이터를 제출(POST)한 후, 서버가 즉시 다른 페이지로 리다이렉트(Redirect)하고, 브라우저가 다시 GET 요청을 보내는 방식으로 동작하죠.          
          
 이 패턴은 세 단계로 이루어집니다.
Post: 사용자가 웹 폼(예: 회원가입, 결제)을 통해 데이터를 POST 방식으로 서버에 제출합니다.
Redirect: 서버는 데이터를 처리한 후, 사용자에게 성공 페이지나 다른 페이지로 이동하라는 HTTP 302 Redirect 응답을 보냅니다.
Get: 브라우저는 서버로부터 받은 Redirect 응답에 따라 새로운 URL로 GET 요청을 보냅니다.
          

**TDD, JUnit , Given When Then**          
 TDD (Test-Driven Development)  : 개발 방법론 중 하나로, 코드를 작성하기 전에 먼저 테스트 코드를 작성하는 방식
    
JUnit
JUnit은 Java 언어를 위한 테스팅 프레임워크입니다. 개발자가 TDD를 실천할 수 있도록 필요한 도구와 환경을 제공하는 역할을 해요.


Given-When-Then 패턴 
Given-When-Then은 하나의 테스트 시나리오를 작성하는 구조 또는 패턴입니다. 테스트의 의도를 명확하고 직관적으로 표현하여 가독성을 높이는 것이 목적이에요.

Given: 테스트를 위한 초기 상태를 설정합니다. (예: "잔액이 10,000원인 계좌가 있다.")
When: 테스트하고자 하는 행동을 정의합니다. (예: "5,000원을 출금한다.")
Then: 그 행동의 예상 결과를 검증합니다. (예: "계좌의 잔액이 5,000원이 되어야 한다.")

세 가지 개념의 관계 🧩
TDD라는 방법론을 따라 개발할 때,
JUnit이라는 도구를 사용하여 테스트 코드를 작성하며,
그 테스트 코드를 Given-When-Then이라는 구조에 맞춰 작성하는 것이 일반적인 흐름입니다.



**Spring Transaction**
트랜잭션 처리의 핵심적인 목적은 데이터베이스 작업의 안정성과 신뢰성을 보장하기 위함. 
ACID라고 불리는 네 가지 속성 : 일관성, 원자성, 격리성 , 지속성을 위한 것. 

@Transactional  : 스프링 AOP 트랜잭션 처리를 위한 애너테이션  
AOP Proxy 기반의 트랜잭션 처리 방식으로 @Transactional 어노테이션이 붙은 클래스에 대해 프록시(대리인) 객체를 만듬. 
이 프록시 객체가 실제 비즈니스 로직을 담고 있는 객체를 대신하여 사용하는 측의 요청을 받고 트랜잭션 처리를 대행함  
사용하는 측에서 @Transactional 적용된 메소드를 호출하면,  AOP Proxy가 트랜잭션 시작, 커밋(commit), 롤백(rollback)과 같은 기능을 수행함 .비즈니스 로직이 모두 성공적으로 완료되면 프록시는 트랜잭션을 커밋하고, 
만약 예외가 발생하면 트랜잭션을 롤백함
       
@Transactional : 데이터베이스에 데이터를 저장, 수정, 삭제하는 DML(INSERT, UPDATE, DELETE) 작업을 수행할 때 사용됨
                         지정한 트랜잭션 내에 문제없이 수행되면 COMMIT , 문제 발생하면 자동 롤백 
@Transactional(readOnly = true) : 오직 읽기(Read Only)만 가능한 트랜잭션이 생성 , 성능 향상에 기여 
트랜잭션이 읽기 전용으로 설정되므로, 불필요한 쓰기 관련 오버헤드(Overhead)가 제거되어 성능이 최적화 됨 ,
데이터베이스에 쓰기 락을 걸지 않으므로, 동시성 처리에 유리

서비스 특성에 따라 삽입,삭제,수정 서비스가 중심이라면 
서비스 클래스 단위에서 @Transactional  , 메서드 단위에서 조회서비스에 대해 @Transactional(readOnly = true) 
또는 
조회 서비스가 중심이라면 
서비스 클래스 단위에서 @Transactional(readOnly = true)   , 메서드 단위에서 삽입,삭제,수정 서비스에 대해 
@Transactional 로 처리하면 됨 


 ***AJAX (Asynchronus Javascript And Xml) *** 
   			비동기 자바스크립트 통신 
   			
   			요청에 대한 응답을 웹 페이지가 아니라 필요한 데이터(text or xml or json)로 응답받는다
   			==> 필요데이터로 응답받아 화면에 부분 업데이트 
   			
   			동기적 통신 : 클라이언트가 요청하면 서버가 응답할때까지 대기 
   			비동기적 통신 : 클라이언트가 요청, 클라이언트는 자신의 작업을 진행하다가 서버가 응답하면 업데이트    		    
     		    
   XML 과 JSON : Ajax 통신시 사용하는 데이터 형식
					  구조화된 데이터 송수신을 위해 xml과 json을 이용한다 
			          2005년 이후 초기에는 xml 을 이용했으나 최근에는  json 을 이용한다 
			          
   JSON : JavaScript Object Notation  
             자바스크립트 객체 표기법
             Ajax 통신시 구조화된 데이터를 송수신하는 용도로 사용된다 
             경량이고 높은 생산성이 장점 



          
          
          
          
          
          
          
          





















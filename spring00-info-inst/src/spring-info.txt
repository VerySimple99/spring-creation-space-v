**spring**

주요목차 
- IOC / DI 
- AOP 
- Logging
- MyBatis(SQL Mapper)
- SpringMVC(Spring Legacy) , Ajax(JSON)
- jUnit(TDD)
- SpringBoot
- Thymeleaf
- REST
- Interceptor
- Spring Security 
- JPA(ORM)
======================
- MSA 
- React 와 SpringBoot 

--------------------------------------------

용어정리 
library : 라이브러리 , 재사용 가능한 프로그램들의 모음 
jar : 자바프로그램 압축 확장자 (springboot application을 deploy하기 위해 압축 )
war : 자바 웹어플리케이션 확장자 
component : 독립적 기능단위로 부품화 되는 요소 
			   Bean => 자바 컴포넌트 , 스프링 컨테이너에서 관리하는 객체를 Bean이라고 함
API : Application Programming Interface  응용 프로그램을 개발하기 위해 제공하는 인터페이스 
Framework :  사전적 의미로는 틀  (  frame 틀  + work 일 ) => 일을 잘하기 위한 틀을 제공 
				응용 프로그램의 기반을 제공 
				반완전한 어플리케이션 => 제공 가능한 최대한 지원 => 비즈니스 로직에 집중  
				
Spring Framework 				
			자바 어플리케이션의 설계,구현,테스트,운영에 대한 Infrastructure(기반)를 제공 
		    다양한 컴포넌트와 디자인 패턴을 제공 
		    
		    Spring IOC/DI,AOP,MVC,SpringBoot,SpringSecurity,SpringCloud 등의 기술 지원과 
		    jUnit,MyBatis,Hibernate 등과 같은 프레임워크와의 통합을 지원한다     


**IOC/DI**
- IOC 개념 : 소프트웨어 설계 원리이자 디자인 패턴 
  Inversion Of Control , 역 제어 , 제어의 반전 (역행) 
  Bean 제어를 IOC 컨테이너에 위임 
  필요시 직접 만드는 기존의 제어 방식이 아니라 필요로 하는 요소를 IOC 컨테이너에 위임 
  컴포넌트(Bean)를 구성하는 인스턴스 라이프 사이클과 의존 관계 연결 처리를 IOC  컨테이너에 위임  
  why?  loose coupling  결합도를 느슨하게 한다 
         참고) 결합도란 모듈간의 상호 의존도 , 결합도가 낮다는 것은 유지보수성, 확장성이 높아진다  
  
  

- DI 개념 : 디자인 패턴 
   Dependency Injection , 의존성 주입  	
   필요로 하는 의존성( bean or component ) 을 주입(injection) 을 통해 확보 
   즉 IOC 를 DI 기법을 통해 실현한다 
   
- DL 
   Dependency Lookup  , 의존성 검색     
   필요로 하는 의존성( bean or component ) 을 검색(lookup) 을 통해 확보 
   즉 IOC 를 DL 기법을 통해 실현한다 

- Maven : 프로젝트 관리 도구 , 빌드툴 
            프로젝트에서 필요로 하는 라이브러리를 일괄적으로 관리 ( 원격저장소에서 로컬저장소로 다운로드받아 사용 )
			pom.xml ( project object model : maven 설정 파일 ) 을 형상관리한다
			프로젝트 실행 파일을 maven 으로 생성 ( jar or war ) 해  Deploy 배포한다 

- 어제 내용 복습 
   Framework :  일을 잘하기 위한 틀을 제공 
                   설계 구현 테스트 운영 인프라
   Spring Framework :  자바 어플리케이션에 대한 설계,구현,테스트,운영 전반을 지원하여
                           비즈니스 로직에 집중하게 기반을 제공 
                           IOC , DI , AOP , MVC , SpringBoot, JUnit , MyBatis , JPA 등의 기술을 지원함 
   Maven or Gradle : project build tool , 의존라이브러리관리 , 실행파일을 생성해 deploy                        

   IOC : Inversion Of Control  제어의 역전 
   		  bean (객체 or Component) 의 라이프사이클을 컨테이너에 위임해 관리    
          => Loose Coupling 
          
   DI : Dependency Injection 의존성 주입        
          
  **Spring(spring bean) LifeCycle**
  Bean : 스프링 컨테이너가 관리하는 객체(컴포넌트)
  
  Spring Container 실행 -> Bean 생성 & DI -> 초기화 콜백 @PostConstruct : bean 생성 직후 실행되는 init 메서드  
  -> 서비스 : Bean 기능 실행 -> 소멸 콜백 @PreDestroy : 소멸(서비스해제) 직전 실행되는 destroy 메서드 -> 종료 
 
 * 콜백 : 나중에 다시 호출될 함수나 메서드 
 
 
  🌟 스프링 빈 라이프사이클 상세 설명 (면접 답변 예시)
"스프링 빈 라이프사이클은 스프링 컨테이너(IoC 컨테이너)가 빈(Bean)을 생성하고, 
초기화하며, 사용하고, 최종적으로 소멸시키는 전 과정에서 발생하는 일련의 단계를 의미합니다. 
개발자는 이 라이프사이클의 특정 시점에 원하는 로직을 삽입하여 빈의 동작을 제어할 수 있습니다.

주요 단계는 다음과 같습니다:

빈 정의 로딩 (Bean Definition Loading):
스프링 컨테이너가 XML 설정 파일, Java 어노테이션(@Configuration, @Component 등), 
또는 Java 코드를 통해 빈의 정의(클래스 정보, 의존성 등)를 읽어들입니다.

빈 인스턴스 생성 (Bean Instantiation):
컨테이너가 빈 정의를 바탕으로 new 연산자를 사용하듯이 
해당 클래스의 인스턴스를 생성합니다. (기본적으로는 기본 생성자 호출)

의존성 주입 (Dependency Injection):
생성된 빈의 속성(프로퍼티)에 필요한 의존성(다른 빈)들을 주입합니다. 이는 생성자 주입, Setter 주입, 필드 주입 등 다양한 방식으로 이루어집니다.

초기화 콜백 (Initialization Callbacks):
의존성 주입이 완료된 후, 빈이 사용될 준비를 마치기 위해 초기화 작업을 수행하는 단계입니다. 이 시점에 개발자가 정의한 초기화 로직이 실행됩니다.
초기화 콜백을 지정하는 방법은 주로 세 가지가 있습니다:
@PostConstruct 어노테이션: JSR-250 표준 어노테이션으로, 메서드에 붙여 초기화 시점에 실행됩니다. (JDK 9+ 환경에서는 jakarta.annotation-api 의존성 필요)
InitializingBean 인터페이스: afterPropertiesSet() 메서드를 구현하여 초기화 로직을 정의합니다. (스프링 전용 인터페이스)
XML 설정의 init-method 속성: XML 빈 정의에 초기화 메서드 이름을 지정합니다.

빈 사용 (In Use):
초기화가 완료된 빈은 이제 애플리케이션에서 요청에 따라 사용될 준비가 됩니다. 개발자는 이 빈의 메서드를 호출하여 비즈니스 로직을 수행합니다.

소멸 콜백 (Destruction Callbacks):
스프링 컨테이너가 종료되거나, 스코프가 짧은 빈(예: request, session 스코프)이 수명이 다했을 때, 빈이 소멸되기 직전에 정리 작업을 수행하는 단계입니다. 이 시점에 개발자가 정의한 소멸 로직이 실행됩니다.

소멸 콜백을 지정하는 방법은 주로 세 가지가 있습니다:
@PreDestroy 어노테이션: JSR-250 표준 어노테이션으로, 메서드에 붙여 소멸 시점에 실행됩니다. (JDK 9+ 환경에서는 jakarta.annotation-api 의존성 필요)

DisposableBean 인터페이스: destroy() 메서드를 구현하여 소멸 로직을 정의합니다. (스프링 전용 인터페이스)
XML 설정의 destroy-method 속성: XML 빈 정의에 소멸 메서드 이름을 지정합니다.
빈 소멸 (Bean Destruction):

소멸 콜백이 완료되면, 컨테이너는 해당 빈의 인스턴스를 메모리에서 제거합니다.

이러한 라이프사이클 관리를 통해 스프링은 개발자가 객체의 생성, 의존성 주입, 초기화, 소멸 등의 복잡한 과정을 직접 관리할 필요 없이 비즈니스 로직에만 집중할 수 있도록 도와줍니다. 특히, @PostConstruct와 @PreDestroy는 간편하게 초기화/소멸 로직을 추가할 수 있어 많이 사용됩니다."
  
  
  
  
  
  **Spring 설정 방식**
  XML , Annotation , Java Config 설정 방식이 있다 
  xml + Annoation 조합 또는 Annotation + Java Config 조합으로 설정 된다 
  
  XML 설정 방식 => 소스코드와 설정 분리 
  Annotation 설정 방식 => 소스 코드 상에서 설정이 기술 
  
  **Spring Annotation Config**
  컴포넌트 계열 어노테이션 
  @Component : Spring IOC Container에게 해당 클래스가 bean 생성 대상임을 알리는 어노테이션 
                   bean 으로 라이프 사이클 관리가 되고 Singleton으로 운영된다 
                   @Component : 컴포넌트 계열 어노테이션 상위 타입 , 일반 컴포넌트 클래스에 명시, bean으로 생성,관리됨 
   				   @Component 계열 하위 어노테이션 
   				   @Controller : MVC 중 Controller or Presentation Layer 에 명시
   				   @Repository :  Data Access Object or Persistence Layer 에 명시 
   				   @Service : Business Layer 에 명시  	                
   설정 어노테이션 
   @Configuration :  해당 클래스가 Spring 설정 클래스임을 Spring Container에게 알리는 어노테이션 
   
   @ComponentScan(base package) : 지정한 base package 하위 클래스들을 탐색해 
   								          bean 생성 ,관리 , DI 처리한다  

   DI(Dependency Injection) 관련 어노테이션
   : 스프링 컨테이너로부터 의존성 주입하고자 할때 적용하는 어노테이션 
   DI 는 constructor , field , setter 모두 가능하다 => 권장되는 방식은 constructor  
   @Autowired : 의존성 bean 을 타입으로 검색해 주입.  field , constructor , setter 모두 가능 
   				   @Qualifier(bean name) : 동일한 타입의 여러 bean 이 존재할때 bean name을 명시해 주입할 수 있음 
   				   
   @Resource , @Inject 등의 어노테이션이 있음 				   


   **생성자를 통한 DI를 권장하는 이유**
   - 의존성 확보가 보장된다 ( 엔진 없는 자동차가 생성될 수 없다. 앙꼬없는 찐빵이 만들어 질 수 없다 )
     review : 생성자를 명시하는 이유는 객체 생성시 필요한 초기화 작업을 하기 위해 
               ( 자동차를 생성하기 위한 초기화 작업은 엔진 생성 , 찐빵 생성 초기화 작업은 앙꼬 ) 
     setter , field injection 은 의존성 즉 필요로 하는 객체를 생성해 주입하지 않아도 
     객체 생성이 가능 
     NPE(NullPointerException) 을 사전에 방지할 수 있다
   
   - 단위 테스트에 용이 
      의존 관계를 가지는 다양한 객체를 생성해서 생성자에 주입해 테스트 해볼 수 있다 
      
   - 객체를 불변으로 만들 수 있다 => final 로 처리할 수 있다 ( 이후 적용 예정 ) 
     setter 또는 field injection 은 final 로 처리할 수 없고 
     오직 Constructor injection 만 가능 
     처음 객체 생성시 생성자에서 주입받은 bean 즉 의존성이 이후 변경 불가능하도록 처리할 수 있다 
     
     => why? 의존성 확보 보장 , 불변성 보장 , 단위 테스트 용이 
     
     **AOP**
     Aspect Oriented Programming  관점 지향 프로그래밍 
     Aspect => 관점   Core Concern 핵심관심사 + Cross Cutting Concern 횡단관심사 or 공통관심사 
     시스템을 핵심관심사항과 공통관심사항으로 구분해 분석,설계,구현,운영한다 
     공통,반복 작업을 피하고 효과적인 유지보수가 가능 => 응집도를 높이고 결합도 낮춘다 
     =>응집도를 높임: core 담당자는 core에 집중 , cross cutting 공통관심사(ex-보안,로깅,트랜잭션..) 담당자는 자신의 역할에 집중 
     =>결합도를 낮춤: 공통 관심사 로직이 변경될 때 기존 코드는 수정이 필요하지 않고 해당 AOP 공통관심사 로직만 변경하면 됨                    
     spring pdf 의 그림 참조 (aop 적용전과 후 그림을 확인) 

      Core Concern(핵심관심사) : 시스템 업무 목적에 해당하는 주요 로직 ( ex- 회원관리, 결제 등 )
      Cross Cutting Concern(횡단 or 공통관심사) : 시스템 여러 부분에 걸쳐 적용되는 공통 로직 
      													(ex- 트랜잭션 , 보안 , 로깅 등 )
   - AOP 동작원리 
     Proxy Design Pattern 
     Proxy 는 대리인을 의미 , 대신해서 Cross Cutting Concern 공통 로직을 수행 
     사용하는 측과 서비스를 제공하는 측의 매개자로서 Proxy 객체가 역할을 담당 
     ( ex - 아이유팬  <--> 아이유 매니저(cross cutting) <--> 아이유(core) )   													

  - Logging : Logging 관련 구현체 ( Log4j , Logback.. ) 
               Slf4j : Logging 관련 구현체의 추상 계층 
           
   로깅 : 시스템 동작에 관한 정보를 제공하는 기록
          주로 시스템 실행 정보 및 성능,에러에 대한 정보를 저장, 제공 
           참고 ) System.out.println() -> 개발 및 운영에 대한 로그 레벨을 지정할 수 없고 
            파일과 같은 곳에 저장할 수도 없어 정보를 유지할 수 없음
            -> Logging 관련 기술에 필요    

      자바 진영에서 사용하는 로깅 프레임워크는 대표적으로 Log4j , Logback 등이 있음 
     
      로깅 프레임워크 특징 
      설정파일( logback.xml , log4j.xml ) 에서 패키지별로 레벨 설정이 가능 
      지정한 레벨 등급 이상의 로그만 기록하고 저장하는 방식
      파일 로깅, 용량설정 , 실행시 설정변경 적용 등 여러 기능이 제공       

      로그레벨 (log level)    :  만약 로그레벨을 INFO 로 설정하면  ERROR,WARN,INFO 가 로깅 
      ERROR
      WARN
      INFO
      DEBUG
      TRACE  

       - SLF4J : Simple Logging Facade -> Facade 는 사전적 의미로 표면 ,겉면 -> 인터페이스를 의미 
        SLF4J 는 로깅 퍼사드로서  여러 로깅 라이브러리 구현체들 ( Log4j , Logback 등 ) 을 
        하나의 통일된 방식으로 사용할 수 있는 방법을 제공 , 캡슐화 
        SLF4J 방식으로 개발하면 이후 로깅 구현체가 변경되어도 별도의 수정이 없다는 장점이 있음         
           
  **MyBatis Framework**
   영속성 계층 프레임워크  Persistence Layer Framework => SQL Mapper Framework ( 자바 어플리케이션과 SQL 을 연결 )
   DAO ( Data Access Object ) 를 효율적으로 개발 
   데이터베이스 연동 자바 프로그램을 효율적으로 개발하고 운영할 수 있게 지원한다          
           
           
 **Spring MVC**

   Spring Framework 기반 java web application 구현을 위한 기술 

   

   - Spring MVC 의 주요 디자인 패턴 

     MVC Design Pattern ( 실세계의 예 : 식당 - 주방 , 메뉴판 or 음식  , 키오스크 ) 
      Model : 비즈니스 로직과  데이터 액세스 로직 
      View :  클라이언트로의  response를 전담 
      Controller :  request 분석 , Model 연동 , View 선택해 응답 

     Front Controller Design Pattern    
         모든 클라이언트의 요청을 한 곳을 집중시켜 공통 정책을 수행
         인코딩 , 보안(인증과 인가) , 예외처리와 같은 공통 정책을 효과적으로 수행할 수 있다 
         ( 실세계의 예 :  콜센터 or 호텔 프론트 ) 
         

     - Spring MVC  요청과 응답까지의 실행 흐름 
       client 가 request 하면 DispatcherServlet 가 동작되고 실제 컨트롤러를 연결할 
       HandlerMapping 이 컨트롤러 구현체를 연결하고 HandlerAdapter 가 컨트롤러 메서드를 
       실행한다   클라이언트에게 응답할 방식을 ViewResolver가 제공하여 
       그에 따라 클라이언트에게 View(jsp/ajax-json/thymeleaf 등) 를 응답한다      

    

    Spring MVC 의 주요 컴포넌트 
    - DispatcherServlet : Front Controller 역할을 담당 , Spring 설정을 로딩 - IOC / DI 처리를 지원
    - HandlerMapping : 요청을 처리할 컨트롤러를 연결 ( RequestMappingHandlerMapping ) 
    - HandlerAdapter : Controller를 실행하는 역할 , 
                           컨트롤러 메서드에서 필요로 하는 데이터를 가공해 전달해줌 
                           ( request.getParameter() 를 대행하여 vo 로 전달, 자동형변환 등을 지원 ) 
     - ModelAndView : Model 과 연동한 정보 -> request.setAttribute(name,value) 
         와 View 정보 -> /WEB-INF/views/ok.jsp  에서 view name : ok                      
     - ViewResolver : 클라이언트에게 응답할 방식을 지원 
       jsp or thymeleaf or ajax json 등의 방식을 지원      

        
    SpringMVC의 주요 어노테이션 
    @Controller : 컨트롤러 로직을 처리하는 클래스 
    @RequestMapping : 요청 url과 controller method를 mapping 
    @GetMapping : get 방식만 지원 - 아니면 http response status code : 405
    @PostMapping : post 방식만 지원   - 아니면 http response status code : 405
    @ResponseBody : ajax 응답을 위한 어노테이션 
    @RestController : Rest API Service를 위한 컨트롤러 -> @Controller + @ResponseBody           
           
           
           
           
                
  감사합니다			   


  
  
  
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          




















